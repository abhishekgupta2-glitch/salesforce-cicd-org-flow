name: ðŸ”„ SIT Promotion & Deployment (Dev â†’ SIT Branch â†’ SIT Org)

on:
  pull_request:
    types: [closed]
    branches:
      - CRM_DevTrial2
      - CRM_SITTrial
    paths-ignore:
      - '**.md'
      - '.gitignore'

jobs:
  promote-to-sit:
    runs-on: ubuntu-latest
    # Only run if PR to CRM_DevTrial2 is merged and from promotional branch
    # This job creates the SIT promotional branch and PR
    # NOTE: This runs after DevTrial deployment, but may run simultaneously
    # The sequential execution is ensured by the fact that both need the PR to be merged
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'CRM_DevTrial2' &&
      startsWith(github.event.pull_request.head.ref, 'promo/')
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.merge_commit_sha }}
      
      # Step 2: Configure Git
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step 3: Setup Node
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 4: Install Salesforce CLI
      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global

      # Step 5: Install sfdx-git-delta
      - name: Install sfdx git delta
        run: |
          echo Y | sfdx plugins:install sfdx-git-delta
          sfdx plugins

      # Step 6: Install required tools
      - name: Install required tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq bc -qq

      # Step 8: Verify Trigger and Extract Feature Number
      - name: Verify Trigger and Extract Feature Number
        id: verify-trigger-promote
        run: |
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          HEAD_REF="${{ github.event.pull_request.head.ref }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
          MERGED="${{ github.event.pull_request.merged }}"
          
          if [ "$MERGED" != "true" ]; then
            echo "[ERROR] PR was not merged, only closed"
            exit 1
          fi
          
          echo "[INFO] Checking if this is the correct trigger for SIT promotion..."
          echo "[INFO] Base branch: $BASE_REF"
          echo "[INFO] Head branch: $HEAD_REF"
          echo "[INFO] PR number: $PR_NUMBER"
          echo "[INFO] Merge commit: $MERGE_COMMIT"
          
          # CRITICAL: Only proceed if this is a PR to CRM_DevTrial2 from promo/ branch
          if [ "$BASE_REF" != "CRM_DevTrial2" ]; then
            echo "[ERROR] This job should only run for PRs to CRM_DevTrial2, but base ref is: $BASE_REF"
            exit 1
          fi
          
          if [[ ! "$HEAD_REF" == promo/* ]]; then
            echo "[ERROR] This job should only run for PRs from promo/ branches, but head ref is: $HEAD_REF"
            exit 1
          fi
          
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "merge_commit=$MERGE_COMMIT" >> $GITHUB_OUTPUT
          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "[INFO] âœ… Valid trigger confirmed - CRM_DevTrial2 PR #$PR_NUMBER was merged"

      # Step 9: Extract feature number and create SIT promotional branch
      - name: Create SIT Promotional Branch
        id: create-sit-promo
        if: steps.verify-trigger-promote.outcome == 'success'
        run: |
          PROMO_BRANCH="${{ steps.verify-trigger-promote.outputs.head_ref }}"
          MERGE_COMMIT="${{ steps.verify-trigger-promote.outputs.merge_commit }}"
          FEATURE_NUM=$(echo "$PROMO_BRANCH" | sed 's/promo\///g')
          SIT_PROMO_BRANCH="sit-promo/$FEATURE_NUM"
          
          echo "[INFO] Original promo branch: $PROMO_BRANCH"
          echo "[INFO] Feature number: $FEATURE_NUM"
          echo "[INFO] Creating SIT promotional branch: $SIT_PROMO_BRANCH"
          echo "[INFO] Merge commit from CRM_DevTrial2: $MERGE_COMMIT"
          
          # Fetch CRM_SITTrial branch
          git fetch origin CRM_SITTrial || git fetch origin main
          
          BASE_BRANCH="CRM_SITTrial"
          BASE_COMMIT=$(git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          
          echo "[INFO] Base branch: $BASE_BRANCH"
          echo "[INFO] Base commit: $BASE_COMMIT"
          echo "[INFO] Current HEAD: $(git rev-parse HEAD)"
          
          # Check if SIT promotional branch already exists
          if git ls-remote --heads origin "$SIT_PROMO_BRANCH" | grep -q "$SIT_PROMO_BRANCH"; then
            echo "[INFO] SIT promotional branch already exists"
            git fetch origin "$SIT_PROMO_BRANCH"
            git checkout -b "$SIT_PROMO_BRANCH" "origin/$SIT_PROMO_BRANCH" 2>/dev/null || git checkout "$SIT_PROMO_BRANCH"
            git reset --hard origin/$BASE_BRANCH || git reset --hard origin/main
            echo "[INFO] SIT promotional branch reset to $BASE_BRANCH"
          else
            echo "[INFO] Creating new SIT promotional branch from $BASE_BRANCH"
            git checkout -b "$SIT_PROMO_BRANCH" origin/$BASE_BRANCH || git checkout -b "$SIT_PROMO_BRANCH" origin/main
          fi
          
          # Merge the merged commit from CRM_DevTrial2 into SIT promotional branch
          echo "[INFO] Merging merged commit into SIT promotional branch..."
          
          # Check if merge commit is already in SIT promo branch
          if git merge-base --is-ancestor "$MERGE_COMMIT" HEAD 2>/dev/null; then
            echo "[INFO] Merge commit already in SIT promotional branch"
            echo "sit_promo_branch=$SIT_PROMO_BRANCH" >> $GITHUB_OUTPUT
            echo "merge_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Try merge in dry-run mode first
          git merge --no-commit --no-ff "$MERGE_COMMIT" || {
            echo "[ERROR] Merge conflict detected!"
            git merge --abort 2>/dev/null || true
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          }
          
          git merge --abort
          
          # Perform actual merge
          git merge --no-ff "$MERGE_COMMIT" -m "Merge $MERGE_COMMIT from CRM_DevTrial2 into SIT promotional branch" || {
            echo "[ERROR] Failed to merge into SIT promotional branch"
            git merge --abort 2>/dev/null || true
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          }
          
          echo "[INFO] âœ… Successfully merged $MERGE_COMMIT into $SIT_PROMO_BRANCH"
          
          echo "sit_promo_branch=$SIT_PROMO_BRANCH" >> $GITHUB_OUTPUT
          echo "merge_success=true" >> $GITHUB_OUTPUT
          echo "[INFO] âœ… SIT promotional branch created and merged successfully"

      # Step 10: Generate Delta Packages
      - name: Generate Delta Packages for SIT
        id: delta-generation-sit
        if: steps.create-sit-promo.outputs.merge_success == 'true'
        run: |
          mkdir -p changed-sources-sit
          SIT_PROMO_BRANCH="${{ steps.create-sit-promo.outputs.sit_promo_branch }}"
          BASE_BRANCH="CRM_SITTrial"
          MERGE_COMMIT="${{ steps.verify-trigger-promote.outputs.merge_commit }}"
          
          echo "[INFO] Generating delta for SIT environment"
          echo "[INFO] Comparing $BASE_BRANCH to $SIT_PROMO_BRANCH"
          
          git fetch origin "$BASE_BRANCH" || git fetch origin main
          BASE_COMMIT=$(git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          
          echo "[INFO] Base commit (CRM_SITTrial): $BASE_COMMIT"
          echo "[INFO] Current commit (sit-promo after merge): $(git rev-parse HEAD)"
          echo "[INFO] Merge commit from CRM_DevTrial2: $MERGE_COMMIT"
          
          # First, check what files changed in the merge commit compared to base
          echo "[INFO] Checking what changed in merge commit vs CRM_SITTrial..."
          CHANGED_FILES=$(git diff --name-only "$BASE_COMMIT" "$MERGE_COMMIT" -- "force-app/" 2>/dev/null || echo "")
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "[INFO] Files changed in merge commit:"
            echo "$CHANGED_FILES" | head -20
          else
            echo "[INFO] No files changed in merge commit (compared to CRM_SITTrial)"
          fi
          
          # Generate delta comparing BASE to HEAD (after merge)
          set +e
          sf sgd source delta \
            --from "$BASE_COMMIT" \
            --to "HEAD" \
            --output-dir "changed-sources-sit" \
            --generate-delta \
            --source-dir "force-app" 2>&1 | tee delta-output.log
          DELTA_EXIT_CODE=$?
          set -e
          
          echo "[INFO] Delta generation exit code: $DELTA_EXIT_CODE"
          
          # Check for changes more thoroughly - look for any files in the output directory
          HAS_CHANGES=false
          
          # Check if force-app directory exists and has content
          if [ -d "changed-sources-sit/force-app" ]; then
            # Count files recursively (including metadata files)
            FILE_COUNT=$(find changed-sources-sit/force-app -type f 2>/dev/null | wc -l | tr -d ' ')
            echo "[INFO] Found $FILE_COUNT file(s) in delta output"
            
            if [ "$FILE_COUNT" -gt 0 ]; then
              HAS_CHANGES=true
              echo "[INFO] Listing changed files:"
              find changed-sources-sit/force-app -type f | head -20
            fi
          fi
          
          # Also check for manifest file which indicates changes
          if [ -f "changed-sources-sit/package.xml" ] || [ -f "changed-sources-sit/destructiveChanges.xml" ]; then
            HAS_CHANGES=true
            echo "[INFO] Found manifest files (package.xml or destructiveChanges.xml)"
          fi
          
          # If delta didn't find changes but git diff shows changes, use git diff directly
          if [ "$HAS_CHANGES" = "false" ] && [ -n "$CHANGED_FILES" ]; then
            echo "[INFO] Delta generation didn't detect changes, but git diff shows changes"
            echo "[INFO] Creating delta package manually from git diff..."
            mkdir -p changed-sources-sit/force-app
            
            # Copy changed files to delta directory
            while IFS= read -r file; do
              if [ -f "$file" ]; then
                target_dir="changed-sources-sit/$(dirname "$file")"
                mkdir -p "$target_dir"
                cp "$file" "changed-sources-sit/$file"
                echo "[INFO] Copied: $file"
              fi
            done <<< "$CHANGED_FILES"
            
            # Re-check for changes
            FILE_COUNT=$(find changed-sources-sit/force-app -type f 2>/dev/null | wc -l | tr -d ' ')
            if [ "$FILE_COUNT" -gt 0 ]; then
              HAS_CHANGES=true
              echo "[INFO] âœ… Created delta package manually with $FILE_COUNT file(s)"
            fi
          fi
          
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "[INFO] âœ… Changes detected for SIT deployment"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "[INFO] âš ï¸ No changes detected for SIT deployment"
            echo "[INFO] Checking git diff to verify..."
            git diff --name-only "$BASE_COMMIT" HEAD | grep -E "force-app|\.xml" | head -10 || echo "[INFO] No differences found in git diff"
          fi

      # Step 11: Run PMD Checks
      - name: Run PMD Apex Checks for SIT
        id: pmd-check-sit
        continue-on-error: true
        if: steps.create-sit-promo.outputs.merge_success == 'true' && steps.delta-generation-sit.outputs.has_changes == 'true'
        run: |
          chmod +x scripts/pmd-check.sh scripts/enhanced-pmd-check.sh
          
          scripts/pmd-check.sh changed-sources-sit/force-app .pmd/apex-ruleset.xml 2>&1 | tee pmd-output-sit.log
          
          VIOLATION_COUNT=0
          if [ -f pmd-violation-count.txt ]; then
            VIOLATION_COUNT=$(cat pmd-violation-count.txt 2>/dev/null || echo "0")
          fi
          
          if [ "$VIOLATION_COUNT" -gt 0 ]; then
            echo "[WARN] âš ï¸ PMD found $VIOLATION_COUNT violation(s) - Showing in summary (non-blocking)"
          else
            echo "[INFO] âœ… PMD checks passed - No violations found"
          fi
          
          echo "pmd_passed=true" >> $GITHUB_OUTPUT
          echo "pmd_violations=$VIOLATION_COUNT" >> $GITHUB_OUTPUT

      # Step 12: Run Apex Tests against SIT Promotional Branch
      - name: Run Apex Tests against SIT Promotional Branch
        id: apex-tests-sit
        if: steps.create-sit-promo.outputs.merge_success == 'true' && steps.pmd-check-sit.outputs.pmd_passed == 'true' && steps.delta-generation-sit.outputs.has_changes == 'true'
        run: |
          chmod +x scripts/run-apex-tests.sh
          scripts/run-apex-tests.sh force-app test_results_sit.json
          
          if [ ! -f test_results_sit.json ]; then
            echo "[ERROR] Test results file not generated"
            exit 1
          fi
          
          echo "[INFO] âœ… Apex test validation passed against SIT promotional branch"
          echo "tests_passed=true" >> $GITHUB_OUTPUT

      # Step 13: Push SIT Promotional Branch and Create/Update PR
      - name: Push SIT Promotional Branch and Create/Update PR
        # Always create PR if merge succeeded, even if no changes detected (for visibility)
        if: steps.create-sit-promo.outputs.merge_success == 'true' && steps.pmd-check-sit.outputs.pmd_passed == 'true' && steps.apex-tests-sit.outputs.tests_passed == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const sitPromoBranch = '${{ steps.create-sit-promo.outputs.sit_promo_branch }}';
            const originalPromoBranch = '${{ steps.verify-trigger-promote.outputs.head_ref }}';
            const prNumber = '${{ steps.verify-trigger-promote.outputs.pr_number }}';
            const mergeSuccess = '${{ steps.create-sit-promo.outputs.merge_success }}' === 'true';
            const hasChanges = '${{ steps.delta-generation-sit.outputs.has_changes }}' === 'true';
            
            // Push SIT promotional branch (handle existing branch)
            const { execSync } = require('child_process');
            try {
              try {
                execSync(`git fetch origin ${sitPromoBranch}`, { stdio: 'pipe' });
                const remoteCommit = execSync(`git rev-parse origin/${sitPromoBranch}`, { encoding: 'utf8' }).trim();
                const localCommit = execSync(`git rev-parse HEAD`, { encoding: 'utf8' }).trim();
                
                if (remoteCommit !== localCommit) {
                  execSync(`git push --force-with-lease origin ${sitPromoBranch}`, { stdio: 'inherit' });
                } else {
                  console.log(`â„¹ï¸ Branch ${sitPromoBranch} is already up to date`);
                }
              } catch (fetchError) {
                execSync(`git push -u origin ${sitPromoBranch}`, { stdio: 'inherit' });
              }
              console.log(`âœ… SIT promotional branch ${sitPromoBranch} pushed successfully`);
            } catch (error) {
              console.log(`âš ï¸ Error pushing branch: ${error.message}`);
              if (!error.message.includes('up to date')) {
                try {
                  execSync(`git push --force-with-lease origin ${sitPromoBranch}`, { stdio: 'inherit' });
                  console.log(`âœ… Force push successful`);
                } catch (forceError) {
                  throw forceError;
                }
              }
            }
            
            // Check if PR already exists
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${sitPromoBranch}`,
              base: 'CRM_SITTrial',
              state: 'open'
            });
            
            const prBody = `## SIT Promotional Branch Validation Results\n\n**Original Promo Branch:** \`${originalPromoBranch}\`\n**SIT Promotional Branch:** \`${sitPromoBranch}\`\n**Merged from:** CRM_DevTrial2 (PR #${prNumber})\n\n**Validation Status:** âœ… Passed\n\n**Merge Status:** ${mergeSuccess ? 'âœ… Success' : 'âŒ Failed'}\n**Changes Detected:** ${hasChanges ? 'âœ… Yes' : 'âš ï¸ No changes detected (may already be in CRM_SITTrial)'}\n\nâœ… Merge validation passed\nâœ… PMD checks passed\nâœ… Apex tests validated against SIT promotional branch\n\nâš ï¸ **Deployment to CRM_SITOrg will happen automatically after PR merge**\n\nâœ… Ready for review and merge`;
            
            if (existingPRs.length > 0) {
              const existingPR = existingPRs[0];
              console.log(`â„¹ï¸ PR already exists: ${existingPR.html_url}`);
              
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: existingPR.number,
                body: prBody,
                title: `SIT Promotional Branch: ${sitPromoBranch} (Updated)`
              });
              
              console.log(`âœ… PR updated: ${existingPR.html_url}`);
            } else {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `SIT Promotional Branch: ${sitPromoBranch}`,
                head: sitPromoBranch,
                base: 'CRM_SITTrial',
                body: prBody,
                draft: false
              });
              
              console.log(`âœ… PR created: ${pr.html_url}`);
            }

  deploy-to-sit-org:
    runs-on: ubuntu-latest
    # IMPORTANT: This job ONLY runs when PR from sit-promo/ branch to CRM_SITTrial is merged
    # It does NOT run when CRM_DevTrial2 PR is merged
    # Sequential flow: CRM_DevTrial2 PR merged â†’ promote-to-sit runs â†’ creates SIT PR â†’ SIT PR merged â†’ deploy-to-sit-org runs
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'CRM_SITTrial' &&
      startsWith(github.event.pull_request.head.ref, 'sit-promo/')
    
    permissions:
      contents: write
      pull-requests: write
      checks: write
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.merge_commit_sha }}
      
      # Step 2: Configure Git
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step 3: Setup Node
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 4: Install Salesforce CLI
      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global

      # Step 5: Install sfdx-git-delta
      - name: Install sfdx git delta
        run: |
          echo Y | sfdx plugins:install sfdx-git-delta
          sfdx plugins

      # Step 6: Install required tools
      - name: Install required tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq bc -qq

      # Step 7: Verify PR Merge Status and Trigger Validation
      - name: Verify PR Merge Status and Trigger Validation
        id: verify-merge-sit
        run: |
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          HEAD_REF="${{ github.event.pull_request.head.ref }}"
          MERGED="${{ github.event.pull_request.merged }}"
          
          echo "[INFO] Checking if this is the correct trigger for SIT deployment..."
          echo "[INFO] Base branch: $BASE_REF"
          echo "[INFO] Head branch: $HEAD_REF"
          echo "[INFO] Merged: $MERGED"
          
          # CRITICAL: Only proceed if this is a PR to CRM_SITTrial from sit-promo/ branch
          if [ "$BASE_REF" != "CRM_SITTrial" ]; then
            echo "[ERROR] This job should only run for PRs to CRM_SITTrial, but base ref is: $BASE_REF"
            echo "[ERROR] Exiting - this job should not run for CRM_DevTrial2 PR merges"
            exit 1
          fi
          
          if [[ ! "$HEAD_REF" == sit-promo/* ]]; then
            echo "[ERROR] This job should only run for PRs from sit-promo/ branches, but head ref is: $HEAD_REF"
            exit 1
          fi
          
          if [ "$MERGED" != "true" ]; then
            echo "[ERROR] PR was not merged, only closed"
            exit 1
          fi
          
          echo "[INFO] âœ… Valid trigger confirmed - SIT PR #${{ github.event.pull_request.number }} was merged"
          echo "[INFO] Merged by: ${{ github.event.pull_request.merged_by.login }}"
          echo "[INFO] Merge commit: ${{ github.event.pull_request.merge_commit_sha }}"
          echo "merge_verified=true" >> $GITHUB_OUTPUT
          echo "merged_by=${{ github.event.pull_request.merged_by.login }}" >> $GITHUB_OUTPUT

      # Step 9: Generate Delta Packages
      - name: Create delta packages for SIT Org
        id: delta-generation-sit-org
        if: steps.verify-merge-sit.outputs.merge_verified == 'true'
        run: |
          mkdir -p changed-sources-sit-org
          BASE_BRANCH="CRM_SITTrial"
          MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
          
          echo "[INFO] Generating delta for SIT Org deployment"
          
          git fetch origin "$BASE_BRANCH" || git fetch origin main
          BASE_COMMIT=$(git rev-parse ${MERGE_COMMIT}^1 2>/dev/null || git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          
          echo "[INFO] Base commit: $BASE_COMMIT"
          echo "[INFO] Merge commit: $MERGE_COMMIT"
          
          # Generate delta with better error handling
          set +e
          sf sgd source delta \
            --from "$BASE_COMMIT" \
            --to "$MERGE_COMMIT" \
            --output-dir "changed-sources-sit-org" \
            --generate-delta \
            --source-dir "force-app" 2>&1 | tee delta-output-sit-org.log
          DELTA_EXIT_CODE=$?
          set -e
          
          echo "[INFO] Delta generation exit code: $DELTA_EXIT_CODE"
          
          # Check for changes more thoroughly - look for any files in the output directory
          HAS_CHANGES=false
          
          # Check if force-app directory exists and has content
          if [ -d "changed-sources-sit-org/force-app" ]; then
            # Count files recursively (including metadata files like sharing rules)
            FILE_COUNT=$(find changed-sources-sit-org/force-app -type f 2>/dev/null | wc -l | tr -d ' ')
            echo "[INFO] Found $FILE_COUNT file(s) in delta output"
            
            if [ "$FILE_COUNT" -gt 0 ]; then
              HAS_CHANGES=true
              echo "[INFO] Listing changed files:"
              find changed-sources-sit-org/force-app -type f | head -20
            fi
          fi
          
          # Also check for manifest file which indicates changes
          if [ -f "changed-sources-sit-org/package.xml" ] || [ -f "changed-sources-sit-org/destructiveChanges.xml" ]; then
            HAS_CHANGES=true
            echo "[INFO] Found manifest files (package.xml or destructiveChanges.xml)"
          fi
          
          # Check delta output log for any indication of changes
          if grep -qi "generating\|success\|changed\|delta" delta-output-sit-org.log 2>/dev/null; then
            echo "[INFO] Delta generation log indicates activity"
          fi
          
          if [ "$HAS_CHANGES" = "true" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "[INFO] âœ… Changes detected for SIT Org deployment"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "[INFO] âš ï¸ No changes detected for SIT Org deployment"
            echo "[INFO] Checking git diff to verify..."
            git diff --name-only "$BASE_COMMIT" "$MERGE_COMMIT" | grep -E "force-app|\.xml" | head -10 || echo "[INFO] No differences found in git diff"
          fi

      # Step 10: Authorize CRM_SITOrg (JWT)
      - name: Authorize CRM_SITOrg (JWT)
        if: steps.verify-merge-sit.outputs.merge_verified == 'true' && steps.delta-generation-sit-org.outputs.has_changes == 'true'
        run: |
          echo "${{ secrets.SF_JWT_KEY_SITORG }}" > server.key
          sf org login jwt \
            --username "${{ secrets.SF_USERNAME_SITORG }}" \
            --jwt-key-file server.key \
            --client-id "${{ secrets.SF_CLIENT_ID_SITORG }}" \
            --instance-url "${{ secrets.SF_INSTANCE_URL_SITORG }}" \
            --set-default \
            --alias CRM_SITOrg

      # Step 11: Validate Deployment and Run Tests BEFORE Deployment (Like Change Sets)
      - name: Validate Deployment and Run Tests (Pre-Deployment Check)
        if: steps.verify-merge-sit.outputs.merge_verified == 'true' && steps.delta-generation-sit-org.outputs.has_changes == 'true'
        id: pre-deploy-validation-sit
        env:
          SF_ORG_ALIAS: CRM_SITOrg
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Pre-Deployment Validation (Like Change Sets)"
          echo "[INFO] =========================================="
          
          if [ ! -d "changed-sources-sit-org/force-app" ] || [ -z "$(ls -A changed-sources-sit-org/force-app 2>/dev/null)" ]; then
            echo "[INFO] No changes to deploy. Skipping validation."
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "[INFO] Step 1: Validating deployment syntax..."
          # Validate deployment (dry-run) - checks syntax and dependencies
          sf project deploy validate \
            --source-dir changed-sources-sit-org/force-app \
            --target-org CRM_SITOrg \
            --json > validate_results_sit.json || {
              echo "[ERROR] Deployment validation failed"
              cat validate_results_sit.json
              echo "validation_passed=false" >> $GITHUB_OUTPUT
              exit 1
            }
          
          VALIDATION_STATUS=$(jq -r '.status' validate_results_sit.json 2>/dev/null || echo "unknown")
          echo "[INFO] Validation status: $VALIDATION_STATUS"
          
          if [ "$VALIDATION_STATUS" != "0" ] && [ "$VALIDATION_STATUS" != "Succeeded" ]; then
            echo "[ERROR] Deployment validation failed"
            jq '.result' validate_results_sit.json 2>/dev/null || cat validate_results_sit.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment validation passed"
          
          echo "[INFO] Step 2: Deploying with test validation (like Change Sets)..."
          echo "[INFO] =========================================="
          echo "[INFO] IMPORTANT: This validates NEW changes from branch against org"
          echo "[INFO] Salesforce CLI with --test-level works like Change Sets:"
          echo "[INFO]   1. Deploys the NEW changes to org"
          echo "[INFO]   2. Runs tests against the NEW changes + existing org code"
          echo "[INFO]   3. If tests fail â†’ Salesforce AUTOMATICALLY rolls back"
          echo "[INFO]   4. If tests pass â†’ Deployment completes successfully"
          echo "[INFO] =========================================="
          
          # Verify org connection
          sf org display --target-org CRM_SITOrg || {
            echo "[ERROR] Cannot connect to CRM_SITOrg. Please check authentication."
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          }
          
          # Deploy with --test-level: Salesforce validates NEW changes during deployment
          # If tests fail, Salesforce automatically rolls back (like Change Sets)
          set +e
          sf project deploy start \
            --source-dir changed-sources-sit-org/force-app \
            --target-org CRM_SITOrg \
            --test-level RunLocalTests \
            --wait 10 \
            --json > deploy_with_validation_results_sit.json 2>&1
          DEPLOY_EXIT_CODE=$?
          set -e
          
          if [ ! -f deploy_with_validation_results_sit.json ] || [ ! -s deploy_with_validation_results_sit.json ]; then
            echo "[ERROR] Deployment validation results file is missing or empty"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check deployment status
          DEPLOY_STATUS=$(jq -r '.status // "unknown"' deploy_with_validation_results_sit.json 2>/dev/null || echo "unknown")
          echo "[INFO] Deployment status: $DEPLOY_STATUS"
          
          # Check if tests were run during deployment
          TESTS_RUN=$(jq -r '.result.testsRun // 0' deploy_with_validation_results_sit.json 2>/dev/null || echo "0")
          TESTS_PASSED=$(jq -r '.result.numberTestsPassed // 0' deploy_with_validation_results_sit.json 2>/dev/null || echo "0")
          TESTS_FAILED=$(jq -r '.result.numberTestsFailed // 0' deploy_with_validation_results_sit.json 2>/dev/null || echo "0")
          
          echo "[INFO] Tests run during deployment: $TESTS_RUN"
          echo "[INFO] Tests passed: $TESTS_PASSED"
          echo "[INFO] Tests failed: $TESTS_FAILED"
          
          # Check deployment status and test results
          if [ "$DEPLOY_STATUS" != "0" ] && [ "$DEPLOY_STATUS" != "Succeeded" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment failed or was rolled back"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            jq '.result' deploy_with_validation_results_sit.json 2>/dev/null || cat deploy_with_validation_results_sit.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ "$TESTS_RUN" = "0" ] || [ "$TESTS_RUN" = "null" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] No tests were executed during deployment"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            cat deploy_with_validation_results_sit.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ "$TESTS_FAILED" -gt 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Tests failed during deployment"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            jq '.result.details' deploy_with_validation_results_sit.json 2>/dev/null || cat deploy_with_validation_results_sit.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment failed (tests may have failed, causing rollback)"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            cat deploy_with_validation_results_sit.json | head -100
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check code coverage from deployment results
          # Coverage includes NEW changes + existing org code
          COVERAGE_RAW=$(jq -r '.result.coverage // .result.coveragePercentage // 0' deploy_with_validation_results_sit.json 2>/dev/null || echo "0")
          
          # Also try to calculate from code coverage array
          if [ "$COVERAGE_RAW" = "0" ] || [ "$COVERAGE_RAW" = "null" ]; then
            TOTAL_COVERED=$(jq -r '[.result.codeCoverage[]?.numLinesCovered // 0] | add' deploy_with_validation_results_sit.json 2>/dev/null || echo "0")
            TOTAL_UNCOVERED=$(jq -r '[.result.codeCoverage[]?.numLinesUncovered // 0] | add' deploy_with_validation_results_sit.json 2>/dev/null || echo "0")
            TOTAL_LINES=$((TOTAL_COVERED + TOTAL_UNCOVERED))
            
            if [ "$TOTAL_LINES" -gt 0 ]; then
              COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_LINES" | bc)
              COVERAGE_RAW=$COVERAGE
            fi
          fi
          
          COVERAGE_CLEAN=$(echo "$COVERAGE_RAW" | sed 's/%//g' | sed 's/[^0-9.]//g' | tr -d ' ')
          COVERAGE_NUM=$(echo "$COVERAGE_CLEAN" | awk '{print $1+0}')
          
          echo "[INFO] Code coverage after deployment (with NEW changes): $COVERAGE_NUM%"
          echo "pre_deploy_coverage=$COVERAGE_NUM" >> $GITHUB_OUTPUT
          
          if awk "BEGIN {exit !($COVERAGE_NUM <= 75)}"; then
            echo "[ERROR] Code coverage is below 75% (Current: $COVERAGE_NUM%)"
            echo "[ERROR] Deployment succeeded but coverage is too low"
            jq '.result.summary' deploy_with_validation_results_sit.json 2>/dev/null || cat deploy_with_validation_results_sit.json | head -50
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment completed successfully"
          echo "[INFO] âœ… NEW changes validated against org"
          echo "[INFO] âœ… Tests passed with new changes"
          echo "[INFO] âœ… Coverage check passed ($COVERAGE_NUM% > 75%)"
          echo "validation_passed=true" >> $GITHUB_OUTPUT

      # Step 12: Deployment already completed in Step 11 with test validation
      # This step is now just for logging and final verification
      - name: Verify Deployment Success (SIT)
        if: steps.verify-merge-sit.outputs.merge_verified == 'true' && steps.delta-generation-sit-org.outputs.has_changes == 'true' && steps.pre-deploy-validation-sit.outputs.validation_passed == 'true'
        id: verify-deployment-sit
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Deployment verification (SIT)"
          echo "[INFO] Deployment completed in Step 11 with test validation"
          echo "[INFO] =========================================="
          
          if [ ! -f deploy_with_validation_results_sit.json ]; then
            echo "[ERROR] Deployment results file not found"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          DEPLOY_STATUS=$(jq -r '.status // "unknown"' deploy_with_validation_results_sit.json 2>/dev/null || echo "unknown")
          echo "[INFO] Final deployment status: $DEPLOY_STATUS"
          
          if [ "$DEPLOY_STATUS" != "0" ] && [ "$DEPLOY_STATUS" != "Succeeded" ]; then
            echo "[ERROR] Deployment verification failed"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment verified successfully"
          echo "deployment_success=true" >> $GITHUB_OUTPUT

      # Step 13: Verify Post-Deployment Coverage
      - name: Verify Post-Deployment Coverage
        if: steps.verify-merge-sit.outputs.merge_verified == 'true' && steps.verify-deployment-sit.outputs.deployment_success == 'true'
        id: apex-sit
        env:
          SF_ORG_ALIAS: CRM_SITOrg
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Post-Deployment Verification"
          echo "[INFO] Verifying org-wide coverage after deployment"
          echo "[INFO] =========================================="
          
          # Run tests again to verify post-deployment state
          set +e
          sf apex run test \
            --test-level RunLocalTests \
            --target-org CRM_SITOrg \
            --code-coverage \
            --json \
            --wait 120 > test_results_sit_org.json 2>&1
          TEST_EXIT_CODE=$?
          set -e
          
          if [ ! -f test_results_sit_org.json ] || [ ! -s test_results_sit_org.json ]; then
            echo "[ERROR] Post-deployment test results file is missing or empty"
            exit 1
          fi
          
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] Post-deployment test execution failed"
            cat test_results_sit_org.json | head -100
            exit 1
          fi
          
          TEST_STATUS=$(jq -r '.status // "unknown"' test_results_sit_org.json 2>/dev/null || echo "unknown")
          
          if [ "$TEST_STATUS" != "0" ] && [ "$TEST_STATUS" != "success" ]; then
            echo "[ERROR] Post-deployment tests failed. Status: $TEST_STATUS"
            jq '.result.summary' test_results_sit_org.json 2>/dev/null || cat test_results_sit_org.json
            exit 1
          fi
          
          # Calculate post-deployment coverage
          TOTAL_COVERED=$(jq -r '[.result.codeCoverage[]?.numLinesCovered // 0] | add' test_results_sit_org.json 2>/dev/null || echo "0")
          TOTAL_UNCOVERED=$(jq -r '[.result.codeCoverage[]?.numLinesUncovered // 0] | add' test_results_sit_org.json 2>/dev/null || echo "0")
          TOTAL_LINES=$((TOTAL_COVERED + TOTAL_UNCOVERED))
          
          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_LINES" | bc)
          else
            COVERAGE_RAW=$(jq -r '.result.summary.orgWideCoverage // 0' test_results_sit_org.json 2>/dev/null || echo "0")
            COVERAGE=$(echo "$COVERAGE_RAW" | sed 's/%//g' | sed 's/[^0-9.]//g' | tr -d ' ')
          fi
          
          COVERAGE_CLEAN=$(echo "$COVERAGE" | sed 's/[^0-9.]//g')
          COVERAGE_NUM=$(echo "$COVERAGE_CLEAN" | awk '{print $1+0}')
          
          PRE_DEPLOY_COVERAGE="${{ steps.pre-deploy-validation-sit.outputs.pre_deploy_coverage }}"
          
          echo "[INFO] Pre-deployment coverage: ${PRE_DEPLOY_COVERAGE}%"
          echo "[INFO] Post-deployment coverage: $COVERAGE_NUM%"
          
          echo "coverage=$COVERAGE_NUM" >> $GITHUB_OUTPUT
          
          if awk "BEGIN {exit !($COVERAGE_NUM <= 75)}"; then
            echo "[ERROR] Post-deployment org-wide coverage is below 75% (Current: $COVERAGE_NUM%)"
            echo "[ERROR] This should not happen as pre-deployment validation passed"
            jq '.result.summary' test_results_sit_org.json 2>/dev/null || cat test_results_sit_org.json | head -50
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "tests_passed=true" >> $GITHUB_OUTPUT
          echo "[INFO] âœ… Post-deployment verification passed"
          echo "[INFO] âœ… Org-wide coverage maintained: $COVERAGE_NUM%"

      # Step 13b: Create Revert PR if Tests Failed
      - name: Create Revert PR if Tests Failed (SIT)
        if: steps.pre-deploy-validation-sit.outputs.validation_passed == 'false' || steps.pre-deploy-validation-sit.outcome == 'failure' || steps.pre-deploy-validation-sit.outputs.tests_failed == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            
            console.log('[ERROR] Tests failed during deployment - Creating revert PR...');
            console.log('[INFO] Salesforce automatically rolled back from org (no manual action needed)');
            console.log('[INFO] This revert PR will remove the changes from the branch');
            
            const BASE_BRANCH = 'CRM_SITTrial';
            const MERGE_COMMIT = '${{ github.event.pull_request.merge_commit_sha }}';
            const ORIGINAL_PR_NUMBER = context.payload.pull_request?.number;
            const ORIGINAL_PR_TITLE = context.payload.pull_request?.title || 'Unknown';
            
            try {
              // Configure git
              execSync('git config --global user.name "github-actions[bot]"', { stdio: 'inherit' });
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"', { stdio: 'inherit' });
              
              // Fetch latest
              execSync(`git fetch origin ${BASE_BRANCH}`, { stdio: 'inherit' });
              
              // Create revert branch
              const revertBranch = `revert/${BASE_BRANCH}-pr-${ORIGINAL_PR_NUMBER}-${Date.now()}`;
              execSync(`git checkout -b ${revertBranch} origin/${BASE_BRANCH}`, { stdio: 'inherit' });
              
              // Revert the merge commit
              try {
                execSync(`git revert -m 1 ${MERGE_COMMIT} --no-edit`, { stdio: 'inherit' });
                console.log(`âœ… Successfully reverted merge commit ${MERGE_COMMIT}`);
              } catch (revertError) {
                console.log(`âš ï¸ Automatic revert failed (may have conflicts): ${revertError.message}`);
              }
              
              // Push revert branch
              try {
                execSync(`git push -u origin ${revertBranch}`, { stdio: 'inherit' });
                
                // Create revert PR
                const revertPRBody = `## âš ï¸ Automatic Revert: Tests Failed During Deployment\n\n` +
                  `**Original PR:** #${ORIGINAL_PR_NUMBER}\n` +
                  `**Original PR Title:** ${ORIGINAL_PR_TITLE}\n` +
                  `**Reason:** Tests failed during deployment validation\n\n` +
                  `**âœ… AUTOMATIC ACTIONS TAKEN:**\n` +
                  `- âœ… Salesforce automatically rolled back from org (NO manual rollback needed)\n` +
                  `- âœ… Pipeline stopped - no further actions executed\n` +
                  `- âœ… Revert PR created and will be automatically merged\n` +
                  `- âœ… Changes automatically removed from branch\n\n` +
                  `**Next Steps:**\n` +
                  `1. Fix test failures or coverage issues in original feature branch\n` +
                  `2. Create new PR after fixes\n\n` +
                  `**Note:** Org is already clean - Salesforce automatically rolled back when tests failed.`;
                
                const { data: revertPR } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[AUTO-REVERT] Revert PR #${ORIGINAL_PR_NUMBER}: ${ORIGINAL_PR_TITLE}`,
                  head: revertBranch,
                  base: BASE_BRANCH,
                  body: revertPRBody,
                  draft: false
                });
                
                console.log(`âœ… Revert PR created: ${revertPR.html_url}`);
                
                // Automatically merge the revert PR
                try {
                  console.log(`ðŸ”„ Auto-merging revert PR #${revertPR.number}...`);
                  
                  // Wait a moment for PR to be fully created
                  await new Promise(resolve => setTimeout(resolve, 2000));
                  
                  // Merge the revert PR
                  const mergeResult = await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: revertPR.number,
                    merge_method: 'merge',
                    commit_title: `[AUTO-MERGE] Revert PR #${ORIGINAL_PR_NUMBER}`,
                    commit_message: `Automatically merged revert PR after test failure during deployment`
                  });
                  
                  console.log(`âœ… Revert PR #${revertPR.number} automatically merged successfully`);
                  console.log(`âœ… Changes removed from ${BASE_BRANCH} branch`);
                } catch (mergeError) {
                  console.log(`âš ï¸ Failed to auto-merge revert PR: ${mergeError.message}`);
                  console.log(`âš ï¸ Please manually merge PR #${revertPR.number}: ${revertPR.html_url}`);
                  
                  // If merge fails due to branch protection or other reasons, try to add a comment
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: revertPR.number,
                      body: `âš ï¸ **Auto-merge failed** - Please merge this PR manually to complete the revert.\n\nReason: ${mergeError.message}`
                    });
                  } catch (commentError) {
                    console.log(`âš ï¸ Could not add comment to PR: ${commentError.message}`);
                  }
                }
                
                console.log(`âœ… No org rollback needed - deployment was prevented`);
              } catch (pushError) {
                console.log(`âš ï¸ Failed to push revert branch: ${pushError.message}`);
              }
            } catch (error) {
              console.log(`[ERROR] Failed to create revert PR: ${error.message}`);
            }
            
            console.log('\n[ERROR] âš ï¸ PRE-DEPLOYMENT VALIDATION FAILED');
            console.log('[ERROR] Deployment was prevented - no changes deployed to org');
            console.log('[ERROR] Revert PR created to remove changes from branch');
            
            // Fail the workflow
            process.exit(1);

      # Step 13: Comment on PR
      - name: Comment on PR
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const mergedBy = '${{ steps.verify-merge-sit.outputs.merged_by }}';
            const prNumber = context.payload.pull_request?.number || context.payload.pull_request.number;
            const deploymentSuccess = '${{ steps.deploy-delta-sit.outputs.deployment_success }}' === 'true';
            const coverage = '${{ steps.apex-sit.outputs.coverage }}';
            const jobStatus = '${{ job.status }}';
            
            let comment = `## SIT Deployment Status\n\n`;
            
            if (jobStatus === 'success' && deploymentSuccess) {
              comment += `âœ… **Status:** Deployment successful\n`;
              comment += `**Merged by:** @${mergedBy}\n`;
              comment += `**Org-Wide Coverage:** ${coverage}%\n`;
              comment += `âœ… Changes deployed to CRM_SITOrg\n`;
              comment += `âœ… Tests passed\n`;
            } else if (jobStatus === 'success' && !deploymentSuccess) {
              comment += `â„¹ï¸ **Status:** No changes to deploy\n`;
            } else {
              comment += `âŒ **Status:** Deployment failed\n`;
              comment += `Please check the workflow logs for details.\n`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      # Step 14: Summary
      - name: Summary
        if: always()
        run: |
          echo "### SIT Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Merged by:** ${{ github.event.pull_request.merged_by.login }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment:** ${{ steps.deploy-delta-sit.outputs.deployment_success }}" >> $GITHUB_STEP_SUMMARY
          echo "**Coverage:** ${{ steps.apex-sit.outputs.coverage }}%" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
