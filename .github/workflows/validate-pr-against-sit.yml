name: Feature Branch Validation and Promotion

on:
  push:
    branches:
      - 'feature/**'  # Triggers on push to any feature branch
    paths-ignore:
      - '**.md'
      - '.gitignore'

jobs:
  precheck-and-promote:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}
      
      # Step 1b: Configure Git
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step 2: Setup Node
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 3: Install Salesforce CLI
      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global

      # Step 4: Install sfdx-git-delta
      - name: Install sfdx git delta
        run: |
          echo Y | sfdx plugins:install sfdx-git-delta
          sfdx plugins

      # Step 5: Install required tools (jq, bc, awk)
      - name: Install required tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq bc -qq

      # Step 6: Create Promotional Branch and Check Merge Conflicts FIRST
      - name: Create Promotional Branch and Validate Merge
        id: validate-merge
        run: |
          FEATURE_BRANCH="${GITHUB_REF#refs/heads/}"
          FEATURE_NUM=$(echo "$FEATURE_BRANCH" | sed 's/feature\///g' | sed 's/feature-//g')
          PROMO_BRANCH="promo/$FEATURE_NUM"
          
          echo "[INFO] Feature branch: $FEATURE_BRANCH"
          echo "[INFO] Creating promotional branch: $PROMO_BRANCH"
          
          # Fetch all branches including promotional branch if it exists
          git fetch origin CRM_DevTrial2 || git fetch origin main
          git fetch origin "$FEATURE_BRANCH"
          git fetch origin "$PROMO_BRANCH" 2>/dev/null || echo "[INFO] Promotional branch doesn't exist remotely yet"
          
          BASE_BRANCH="CRM_DevTrial2"
          BASE_COMMIT=$(git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          
          # Check what the feature branch is based on
          FEATURE_BASE=$(git merge-base "origin/$FEATURE_BRANCH" "origin/main" 2>/dev/null || echo "")
          FEATURE_BASE_DEV=$(git merge-base "origin/$FEATURE_BRANCH" "origin/$BASE_BRANCH" 2>/dev/null || echo "")
          
          echo "[INFO] Base branch: $BASE_BRANCH"
          echo "[INFO] Base commit: $BASE_COMMIT"
          echo "[INFO] Feature commit: $(git rev-parse origin/$FEATURE_BRANCH)"
          echo "[INFO] Feature branch common ancestor with main: $FEATURE_BASE"
          echo "[INFO] Feature branch common ancestor with $BASE_BRANCH: $FEATURE_BASE_DEV"
          
          # Check if feature branch is based on main (not CRM_DevTrial2)
          MAIN_COMMIT=$(git rev-parse origin/main 2>/dev/null || echo "")
          if [ -n "$FEATURE_BASE" ] && [ "$FEATURE_BASE" = "$MAIN_COMMIT" ] && [ -n "$FEATURE_BASE_DEV" ] && [ "$FEATURE_BASE_DEV" != "$BASE_COMMIT" ]; then
            echo "[INFO] ⚠️  Feature branch appears to be created from 'main'"
            echo "[INFO] ⚠️  But promotional branch is based on '$BASE_BRANCH'"
            echo "[INFO] ⚠️  This may cause merge conflicts if main and $BASE_BRANCH have diverged"
            echo "[INFO] ℹ️  Will attempt to merge $BASE_BRANCH into feature branch first to resolve conflicts"
          fi
          
          # Check if promotional branch already exists
          if git ls-remote --heads origin "$PROMO_BRANCH" | grep -q "$PROMO_BRANCH"; then
            echo "[INFO] Promotional branch already exists remotely"
            echo "[INFO] Checking out existing promotional branch"
            git checkout -b "$PROMO_BRANCH" "origin/$PROMO_BRANCH" 2>/dev/null || git checkout "$PROMO_BRANCH"
            echo "[INFO] Current promotional branch commit: $(git rev-parse HEAD)"
            
            # Check if feature branch is already merged into promotional branch
            if git merge-base --is-ancestor "origin/$FEATURE_BRANCH" HEAD 2>/dev/null; then
              echo "[INFO] Feature branch $FEATURE_BRANCH is already merged into promotional branch"
              FEATURE_COMMIT=$(git rev-parse "origin/$FEATURE_BRANCH")
              CURRENT_COMMIT=$(git rev-parse HEAD)
              
              # Check if promotional branch is ahead or equal to feature branch
              if git merge-base --is-ancestor "origin/$FEATURE_BRANCH" HEAD 2>/dev/null && ! git merge-base --is-ancestor HEAD "origin/$FEATURE_BRANCH" 2>/dev/null; then
                echo "[INFO] Promotional branch already contains feature branch changes"
                echo "[INFO] Checking if feature branch has new commits..."
                
                # Check if feature branch has new commits not in promotional branch
                if git rev-list --left-right --count HEAD...origin/$FEATURE_BRANCH | awk '{print $2}' | grep -q '[1-9]'; then
                  echo "[INFO] Feature branch has new commits. Attempting merge..."
                else
                  echo "[INFO] Promotional branch is up to date with feature branch. No merge needed."
                  echo "promo_branch=$PROMO_BRANCH" >> $GITHUB_OUTPUT
                  echo "merge_success=true" >> $GITHUB_OUTPUT
                  echo "base_commit=$BASE_COMMIT" >> $GITHUB_OUTPUT
                  exit 0
                fi
              else
                echo "[INFO] Promotional branch is up to date with feature branch. No merge needed."
                echo "promo_branch=$PROMO_BRANCH" >> $GITHUB_OUTPUT
                echo "merge_success=true" >> $GITHUB_OUTPUT
                echo "base_commit=$BASE_COMMIT" >> $GITHUB_OUTPUT
                exit 0
              fi
            fi
            
            # If feature branch is not merged, reset to base branch for clean merge
            echo "[INFO] Resetting promotional branch to $BASE_BRANCH to ensure clean merge"
            git reset --hard origin/$BASE_BRANCH || git reset --hard origin/main
            echo "[INFO] Promotional branch reset to $BASE_BRANCH for clean merge"
          else
            # Create promotional branch from CRM_DevTrial2
            echo "[INFO] Creating new promotional branch from $BASE_BRANCH"
            git checkout -b "$PROMO_BRANCH" origin/$BASE_BRANCH || git checkout -b "$PROMO_BRANCH" origin/main
          fi
          
          # IMPORTANT: Promotional branch MUST be based on CRM_DevTrial2 to include all previous feature branches
          # Feature branches are created from 'main', so if main and CRM_DevTrial2 have diverged, we need to handle it
          
          echo "[INFO] Promotional branch is based on $BASE_BRANCH (includes all previous feature branches)"
          echo "[INFO] Feature branch is created from 'main'"
          
          # IMPORTANT: CRM_DevTrial2 accumulates changes from multiple feature branches
          # Main is only updated at the end (production copy)
          # So CRM_DevTrial2 will ALWAYS have changes that main doesn't have
          # This is EXPECTED and NORMAL behavior
          
          echo "[INFO] Understanding branch relationships:"
          echo "[INFO]   - Feature branches are created from 'main'"
          echo "[INFO]   - Feature branches are merged into '$BASE_BRANCH' (accumulates changes)"
          echo "[INFO]   - 'main' is only updated at the end (production copy)"
          echo "[INFO]   - So '$BASE_BRANCH' will ALWAYS have changes from other feature branches"
          echo "[INFO]   - This is EXPECTED and NORMAL"
          echo "[INFO]"
          echo "[INFO] Merge strategy:"
          echo "[INFO]   - Promotional branch = '$BASE_BRANCH' (includes all previous feature branches)"
          echo "[INFO]   - Feature branch = based on 'main' (has new changes)"
          echo "[INFO]   - If same file modified in both: conflict (needs manual resolution)"
          echo "[INFO]   - If different files: no conflict (both changes included)"
          
          # Show current state before merging feature branch
          echo "[INFO] Current promotional branch state:"
          echo "[INFO]   HEAD: $(git rev-parse HEAD)"
          echo "[INFO]   Branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "[INFO]   Log (last 3 commits):"
          git log --oneline -3 || echo "Could not get log"
          
          # Now try merging feature branch into promotional branch
          echo "[INFO] Attempting to merge feature branch into promotional branch..."
          echo "[INFO] Feature branch: origin/$FEATURE_BRANCH ($(git rev-parse origin/$FEATURE_BRANCH))"
          
          # Attempt merge and capture output
          set +e
          git merge --no-commit --no-ff "origin/$FEATURE_BRANCH" 2>&1 | tee merge_output.log
          MERGE_EXIT_CODE=$?
          set -e
          
          echo "[INFO] Merge exit code: $MERGE_EXIT_CODE"
          echo "[INFO] Merge output (last 30 lines):"
          tail -30 merge_output.log || cat merge_output.log
          
          # CRITICAL: Check for conflicts using MULTIPLE methods (exit code can be unreliable)
          HAS_CONFLICTS=false
          CONFLICT_FILES=""
          
          # Method 1: Check git status for unmerged files
          if git status --short 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD"; then
            HAS_CONFLICTS=true
            CONFLICT_FILES=$(git diff --name-only --diff-filter=U 2>/dev/null || echo "")
            echo "[ERROR] Conflict detected via git status (unmerged files)"
          fi
          
          # Method 2: Check merge output for conflict keywords
          if grep -qi "CONFLICT\|conflict\|merge conflict\|Automatic merge failed" merge_output.log; then
            HAS_CONFLICTS=true
            if [ -z "$CONFLICT_FILES" ]; then
              CONFLICT_FILES=$(grep -i "CONFLICT" merge_output.log | grep -oP 'Merge conflict in \K[^\s]+' | head -5 | tr '\n' ' ' || echo "")
            fi
            echo "[ERROR] Conflict detected via merge output"
          fi
          
          # Method 3: Check for conflict markers in files
          if find . -type f -name "*.cls" -o -name "*.trigger" -o -name "*.xml" -o -name "*.js" -o -name "*.html" 2>/dev/null | xargs grep -l "^<<<<<<< " 2>/dev/null | head -1 | read -r conflict_file; then
            HAS_CONFLICTS=true
            if [ -z "$CONFLICT_FILES" ]; then
              CONFLICT_FILES=$(find . -type f \( -name "*.cls" -o -name "*.trigger" -o -name "*.xml" -o -name "*.js" -o -name "*.html" \) -exec grep -l "^<<<<<<< " {} \; 2>/dev/null | head -5 | tr '\n' ' ' || echo "")
            fi
            echo "[ERROR] Conflict detected via conflict markers in files"
          fi
          
          # Method 4: Check exit code (backup check)
          if [ $MERGE_EXIT_CODE -ne 0 ] && [ "$HAS_CONFLICTS" = "false" ]; then
            # Exit code non-zero but no conflicts detected - might be other error
            echo "[WARN] Merge exit code is $MERGE_EXIT_CODE but no conflicts detected via other methods"
            echo "[WARN] Checking git status for more details..."
            git status
          fi
          
          # If conflicts detected, FAIL IMMEDIATELY
          if [ "$HAS_CONFLICTS" = "true" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] ❌ MERGE CONFLICT DETECTED - WORKFLOW STOPPING"
            echo "[ERROR] =========================================="
            
            # Show detailed conflict information
            echo "[ERROR] Git status:"
            git status --short 2>/dev/null || echo "Could not get git status"
            
            echo "[ERROR] Conflicting files:"
            if [ -n "$CONFLICT_FILES" ]; then
              echo "$CONFLICT_FILES" | tr ' ' '\n' | grep -v '^$'
            else
              git diff --name-only --diff-filter=U 2>/dev/null || echo "Could not list conflicting files"
            fi
            
            echo "[ERROR] =========================================="
            echo "[ERROR] Conflict Analysis:"
            echo "[ERROR] =========================================="
            echo "[ERROR] Feature branch: $FEATURE_BRANCH (created from 'main')"
            echo "[ERROR] Promotional branch: $PROMO_BRANCH (based on '$BASE_BRANCH')"
            echo "[ERROR] Base commit: $BASE_COMMIT"
            echo "[ERROR] Feature commit: $(git rev-parse origin/$FEATURE_BRANCH)"
            echo "[ERROR] Main commit: $MAIN_COMMIT"
            echo "[ERROR] =========================================="
            echo "[ERROR] **Root Cause:**"
            echo "[ERROR]   - Your feature branch was created from 'main'"
            echo "[ERROR]   - '$BASE_BRANCH' has changes from OTHER feature branches (already merged)"
            echo "[ERROR]   - The SAME file was modified in BOTH:"
            FIRST_CONFLICT=$(echo "$CONFLICT_FILES" | tr ' ' '\n' | head -1)
            if [ -n "$FIRST_CONFLICT" ]; then
              echo "[ERROR]     * Conflicting file: $FIRST_CONFLICT"
            fi
            echo "[ERROR]     * Another feature branch (already in $BASE_BRANCH) also modified it"
            echo "[ERROR]   - This creates a conflict that needs manual resolution"
            echo "[ERROR] =========================================="
            echo "[ERROR] **Why This Happens:**"
            echo "[ERROR]   - '$BASE_BRANCH' accumulates changes from multiple feature branches"
            echo "[ERROR]   - 'main' is only updated at the end (production copy)"
            echo "[ERROR]   - So '$BASE_BRANCH' will ALWAYS have changes that 'main' doesn't have"
            echo "[ERROR]   - This is EXPECTED and NORMAL in your workflow"
            echo "[ERROR] =========================================="
            echo "[ERROR] **Solution - Update Feature Branch with $BASE_BRANCH:**"
            echo "[ERROR] =========================================="
            echo "[ERROR] You need to merge $BASE_BRANCH into your feature branch to include"
            echo "[ERROR] changes from other feature branches, then resolve conflicts:"
            echo "[ERROR]"
            echo "[ERROR]   1. Checkout your feature branch:"
            echo "[ERROR]      git checkout $FEATURE_BRANCH"
            echo "[ERROR]"
            echo "[ERROR]   2. Fetch latest changes:"
            echo "[ERROR]      git fetch origin"
            echo "[ERROR]"
            echo "[ERROR]   3. Merge $BASE_BRANCH into your feature branch:"
            echo "[ERROR]      git merge origin/$BASE_BRANCH"
            echo "[ERROR]"
            echo "[ERROR]   4. Resolve conflicts manually:"
            if [ -n "$CONFLICT_FILES" ]; then
              echo "[ERROR]      - Edit the conflicting files:"
              echo "$CONFLICT_FILES" | tr ' ' '\n' | grep -v '^$' | sed 's/^/        * /'
            fi
            echo "[ERROR]      - Keep changes from both branches where appropriate"
            echo "[ERROR]      - Remove conflict markers (<<<<<<, ======, >>>>>>)"
            echo "[ERROR]"
            echo "[ERROR]   5. Stage resolved files:"
            echo "[ERROR]      git add ."
            echo "[ERROR]"
            echo "[ERROR]   6. Commit the merge:"
            echo "[ERROR]      git commit -m 'Merge $BASE_BRANCH into $FEATURE_BRANCH'"
            echo "[ERROR]"
            echo "[ERROR]   7. Push updated feature branch:"
            echo "[ERROR]      git push origin $FEATURE_BRANCH"
            echo "[ERROR]"
            echo "[ERROR]   8. The workflow will automatically run again"
            echo "[ERROR] =========================================="
            echo "[ERROR] **Important:** This ensures your feature branch includes all"
            echo "[ERROR] changes from other feature branches that were merged into $BASE_BRANCH"
            echo "[ERROR] =========================================="
            
            # Abort merge and fail
            git merge --abort 2>/dev/null || true
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # If merge exit code is non-zero but no conflicts detected, it's an error
          if [ $MERGE_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Merge failed with exit code $MERGE_EXIT_CODE"
            echo "[ERROR] =========================================="
            echo "[ERROR] Merge output:"
            cat merge_output.log
            echo "[ERROR] Git status:"
            git status
            git merge --abort 2>/dev/null || true
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Merge succeeded - commit it
          echo "[INFO] ✅ No conflicts detected - committing merge..."
          git merge --abort 2>/dev/null || true  # Abort dry-run first
          
          # Perform actual merge
          set +e
          git merge --no-ff "origin/$FEATURE_BRANCH" -m "Merge $FEATURE_BRANCH into promotional branch" 2>&1 | tee merge_actual.log
          MERGE_ACTUAL_EXIT=$?
          set -e
          
          if [ $MERGE_ACTUAL_EXIT -ne 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Actual merge failed with exit code $MERGE_ACTUAL_EXIT"
            echo "[ERROR] =========================================="
            echo "[ERROR] Merge output:"
            cat merge_actual.log
            echo "[ERROR] Git status:"
            git status
            git merge --abort 2>/dev/null || true
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Verify merge was successful
          if git status --short 2>/dev/null | grep -q "^UU\|^AA\|^DD\|^AU\|^UA\|^DU\|^UD"; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Conflicts detected after merge commit!"
            echo "[ERROR] =========================================="
            git status
            git reset --hard HEAD~1 2>/dev/null || true  # Undo merge commit
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "promo_branch=$PROMO_BRANCH" >> $GITHUB_OUTPUT
          echo "merge_success=true" >> $GITHUB_OUTPUT
          echo "base_commit=$BASE_COMMIT" >> $GITHUB_OUTPUT
          echo "[INFO] ✅ Promotional branch created and feature branch merged successfully"

      # Step 7: Generate Delta Packages from PROMOTIONAL BRANCH (after merge)
      - name: Create delta packages from promotional branch
        id: delta-generation
        if: steps.validate-merge.outputs.merge_success == 'true'
        run: |
          mkdir -p changed-sources
          PROMO_BRANCH="${{ steps.validate-merge.outputs.promo_branch }}"
          BASE_COMMIT="${{ steps.validate-merge.outputs.base_commit }}"
          
          echo "[INFO] Comparing $BASE_COMMIT to promotional branch HEAD"
          echo "[INFO] This ensures delta matches what will be deployed"
          
          # Generate delta from base to promotional branch HEAD
          sf sgd source delta \
            --from "$BASE_COMMIT" \
            --to "HEAD" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app" || {
              echo "[WARN] Delta generation failed or no changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              exit 0
            }
          
          echo "[INFO] Delta generation complete"
          echo "[INFO] Listing delta output:"
          ls -R changed-sources || echo "No changes detected"
          
          # Check if there are actual changes
          if [ -d "changed-sources/force-app" ] && [ "$(ls -A changed-sources/force-app 2>/dev/null)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "[INFO] Changes detected in force-app"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "[INFO] No changes detected in force-app"
          fi

      # Step 8: Install PMD
      - name: Install PMD
        id: install-pmd
        continue-on-error: true
        if: steps.validate-merge.outputs.merge_success == 'true'
        run: |
          echo "[INFO] Installing PMD for Apex code analysis..."
          
          # Install Java (required for PMD)
          sudo apt-get update -qq
          sudo apt-get install -y openjdk-17-jdk unzip curl -qq
          java -version
          
          PMD_INSTALLED=false
          
          # Try Method 1: PMD 7.0.0
          echo "[INFO] Method 1: Downloading PMD 7.0.0..."
          PMD_VERSION="7.0.0"
          PMD_URL="https://github.com/pmd/pmd/releases/download/pmd_releases%2F${PMD_VERSION}/pmd-bin-${PMD_VERSION}.zip"
          
          DOWNLOAD_OUTPUT=$(curl -L -w "%{http_code}" -o pmd-bin.zip "$PMD_URL" 2>&1)
          HTTP_CODE=$(echo "$DOWNLOAD_OUTPUT" | tail -1)
          
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
            if [ -f pmd-bin.zip ] && [ -s pmd-bin.zip ] && file pmd-bin.zip | grep -q "Zip archive"; then
              echo "[INFO] PMD zip file downloaded successfully"
              unzip -q pmd-bin.zip
              
              if [ -d "pmd-bin-${PMD_VERSION}" ]; then
                sudo mkdir -p /opt/pmd
                sudo cp -r pmd-bin-${PMD_VERSION}/* /opt/pmd/
                sudo chmod +x /opt/pmd/bin/pmd
                echo "/opt/pmd/bin" >> $GITHUB_PATH
                
                if /opt/pmd/bin/pmd --version 2>&1 | head -1; then
                  PMD_INSTALLED=true
                  echo "pmd_available=true" >> $GITHUB_OUTPUT
                  echo "pmd_method=direct" >> $GITHUB_OUTPUT
                  echo "[INFO] ✅ PMD 7.0.0 installed successfully"
                fi
              fi
            fi
          fi
          
          # Try Method 2: PMD 6.55.0 if 7.0.0 failed
          if [ "$PMD_INSTALLED" != "true" ]; then
            echo "[INFO] Method 2: Trying PMD 6.55.0..."
            PMD_VERSION="6.55.0"
            PMD_URL="https://github.com/pmd/pmd/releases/download/pmd_releases%2F${PMD_VERSION}/pmd-bin-${PMD_VERSION}.zip"
            
            rm -f pmd-bin.zip
            DOWNLOAD_OUTPUT=$(curl -L -w "%{http_code}" -o pmd-bin.zip "$PMD_URL" 2>&1)
            HTTP_CODE=$(echo "$DOWNLOAD_OUTPUT" | tail -1)
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
              if [ -f pmd-bin.zip ] && [ -s pmd-bin.zip ] && file pmd-bin.zip | grep -q "Zip archive"; then
                unzip -q pmd-bin.zip
                if [ -d "pmd-bin-${PMD_VERSION}" ]; then
                  sudo mkdir -p /opt/pmd
                  sudo cp -r pmd-bin-${PMD_VERSION}/* /opt/pmd/
                  sudo chmod +x /opt/pmd/bin/pmd
                  echo "/opt/pmd/bin" >> $GITHUB_PATH
                  
                  if /opt/pmd/bin/pmd --version 2>&1 | head -1; then
                    PMD_INSTALLED=true
                    echo "pmd_available=true" >> $GITHUB_OUTPUT
                    echo "pmd_method=direct_v6" >> $GITHUB_OUTPUT
                    echo "[INFO] ✅ PMD 6.55.0 installed successfully"
                  fi
                fi
              fi
            fi
          fi
          
          # Try Method 3: Salesforce Code Analyzer as fallback
          if [ "$PMD_INSTALLED" != "true" ]; then
            echo "[INFO] Method 3: Installing Salesforce Code Analyzer as fallback..."
            if npm install -g @salesforce/sfdx-scanner 2>&1; then
              if npx @salesforce/sfdx-scanner --version 2>&1 || npm list -g @salesforce/sfdx-scanner 2>&1; then
                echo "pmd_available=true" >> $GITHUB_OUTPUT
                echo "pmd_method=scanner" >> $GITHUB_OUTPUT
                PMD_INSTALLED=true
                echo "[INFO] ✅ Salesforce Code Analyzer installed as fallback"
              fi
            fi
          fi
          
          if [ "$PMD_INSTALLED" != "true" ]; then
            echo "[WARN] All PMD installation methods failed. Will use enhanced code validation instead."
            echo "pmd_available=false" >> $GITHUB_OUTPUT
            echo "pmd_method=none" >> $GITHUB_OUTPUT
          fi

      # Step 9: Create PMD Ruleset File
      - name: Create PMD Ruleset
        if: steps.validate-merge.outputs.merge_success == 'true'
        run: |
          echo "[INFO] Creating PMD ruleset file for Apex..."
          mkdir -p .pmd
          
          cat > .pmd/apex-ruleset.xml << 'EOF'
          <?xml version="1.0"?>
          <ruleset name="Apex Rules"
                   xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd">
            <description>PMD ruleset for Apex code quality checks</description>
            <rule ref="category/apex/security.xml"/>
            <rule ref="category/apex/performance.xml"/>
            <rule ref="category/apex/bestpractices.xml"/>
          </ruleset>
          EOF
          
          echo "[INFO] ✅ PMD ruleset created at .pmd/apex-ruleset.xml"

      # Step 10: Run PMD Apex Checks using shell script (Non-blocking - shows violations but doesn't fail)
      - name: Run PMD Apex Checks
        id: pmd-check
        continue-on-error: true
        if: steps.validate-merge.outputs.merge_success == 'true'
        run: |
          chmod +x scripts/pmd-check.sh scripts/enhanced-pmd-check.sh
          
          # Check if there are changes
          if [ "${{ steps.delta-generation.outputs.has_changes }}" != "true" ]; then
            echo "[INFO] No changes detected. PMD checks skipped."
            echo "pmd_passed=true" >> $GITHUB_OUTPUT
            echo "pmd_violations=0" >> $GITHUB_OUTPUT
            echo "pmd_violations_details=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Run PMD checks using shell script (non-blocking mode - always succeeds)
          scripts/pmd-check.sh changed-sources/force-app .pmd/apex-ruleset.xml 2>&1 | tee pmd-output.log
          
          # Parse violations from output or files
          VIOLATION_COUNT=0
          VIOLATION_DETAILS=""
          
          # Try to read violation count from file first
          if [ -f pmd-violation-count.txt ]; then
            VIOLATION_COUNT=$(cat pmd-violation-count.txt 2>/dev/null || echo "0")
          else
            # Extract from log
            VIOLATION_COUNT=$(grep -c "\[ERROR\]\|\[WARN\].*violation" pmd-output.log 2>/dev/null || echo "0")
          fi
          
          # Extract violation details
          if [ -f pmd-violations.json ]; then
            VIOLATION_DETAILS=$(jq -r '.files[] | select(.violations != null) | "\(.filename): \(.violations | length) violation(s)"' pmd-violations.json 2>/dev/null | head -10 | tr '\n' ';' || echo "")
          elif [ -f pmd-violations.txt ]; then
            VIOLATION_DETAILS=$(cat pmd-violations.txt 2>/dev/null | head -10 | tr '\n' ';' || echo "")
          else
            VIOLATION_DETAILS=$(grep -E "\[ERROR\]|\[WARN\].*violation" pmd-output.log 2>/dev/null | head -10 | tr '\n' ';' || echo "")
          fi
          
          if [ "$VIOLATION_COUNT" -gt 0 ]; then
            echo "[WARN] ⚠️ PMD found $VIOLATION_COUNT violation(s) - Showing in summary (non-blocking)"
            echo "[INFO] Violations will be displayed in workflow summary"
          else
            echo "[INFO] ✅ PMD checks passed - No violations found"
          fi
          
          echo "pmd_passed=true" >> $GITHUB_OUTPUT
          echo "pmd_violations=$VIOLATION_COUNT" >> $GITHUB_OUTPUT
          echo "pmd_violations_details=$VIOLATION_DETAILS" >> $GITHUB_OUTPUT

      # Step 11: Run Apex Tests against PROMOTIONAL BRANCH (not org)
      - name: Run Apex Tests against Promotional Branch
        if: steps.validate-merge.outputs.merge_success == 'true' && steps.pmd-check.outputs.pmd_passed == 'true'
        id: apex-tests
        run: |
          chmod +x scripts/run-apex-tests.sh
          
          # Run tests against promotional branch code
          set +e
          scripts/run-apex-tests.sh force-app test_results.json
          TEST_EXIT_CODE=$?
          set -e
          
          if [ ! -f test_results.json ]; then
            echo "[ERROR] ❌ Test results file not generated"
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] ❌ Apex test validation FAILED"
            echo "[ERROR] Test class validation failed - see errors above"
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] ✅ Apex test validation passed against promotional branch"
          echo "tests_passed=true" >> $GITHUB_OUTPUT

      # Step 11b: Handle Test Validation Failure - Close PR and Cleanup
      - name: Handle Test Validation Failure
        if: always() && steps.validate-merge.outputs.merge_success == 'true' && (steps.apex-tests.outputs.tests_passed == 'false' || steps.apex-tests.outcome == 'failure' || steps.apex-tests.outcome == 'cancelled')
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const promoBranch = '${{ steps.validate-merge.outputs.promo_branch }}';
            const featureBranch = '${GITHUB_REF#refs/heads/}';
            
            console.log('[ERROR] ==========================================');
            console.log('[ERROR] Test class validation FAILED');
            console.log('[ERROR] Closing PR and cleaning up promotional branch');
            console.log('[ERROR] ==========================================');
            
            try {
              // Find existing PR for this promotional branch
              const { data: existingPRs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${promoBranch}`,
                base: 'CRM_DevTrial2',
                state: 'open'
              });
              
              if (existingPRs.length > 0) {
                const pr = existingPRs[0];
                console.log(`[INFO] Found existing PR #${pr.number}, closing it...`);
                
                // Add comment explaining why PR is being closed
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  body: `## ❌ PR Closed: Test Class Validation Failed\n\n` +
                    `**Reason:** Test class validation failed during pre-deployment checks\n\n` +
                    `**What happened:**\n` +
                    `- Test classes in the promotional branch failed validation\n` +
                    `- Test classes must have proper @isTest annotations and valid test methods\n` +
                    `- See workflow logs for detailed error messages\n\n` +
                    `**Action Required:**\n` +
                    `1. Fix test class issues in feature branch: \`${featureBranch}\`\n` +
                    `2. Push fixes to feature branch\n` +
                    `3. A new PR will be created automatically after fixes\n\n` +
                    `**Note:** No deployment occurred - validation failed before PR merge.`
                });
                
                // Close the PR
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  state: 'closed'
                });
                
                console.log(`✅ PR #${pr.number} closed successfully`);
              } else {
                console.log(`ℹ️ No existing PR found for ${promoBranch}`);
              }
              
              // Delete the promotional branch since validation failed
              try {
                const { execSync } = require('child_process');
                execSync(`git push origin --delete ${promoBranch}`, { stdio: 'pipe' });
                console.log(`✅ Promotional branch ${promoBranch} deleted`);
              } catch (deleteError) {
                console.log(`⚠️ Could not delete promotional branch: ${deleteError.message}`);
                console.log(`ℹ️ Branch may not exist or may have been deleted already`);
              }
              
            } catch (error) {
              console.log(`[ERROR] Failed to handle test validation failure: ${error.message}`);
            }
            
            console.log('\n[ERROR] ⚠️ TEST CLASS VALIDATION FAILED');
            console.log('[ERROR] PR closed and promotional branch cleaned up');
            console.log('[ERROR] Please fix test class issues and push again');
            
            // Fail the workflow
            process.exit(1);

      # Step 12: Push Promotional Branch and Create/Update PR
      - name: Push Promotional Branch and Create/Update PR
        if: steps.validate-merge.outputs.merge_success == 'true' && steps.pmd-check.outputs.pmd_passed == 'true' && steps.apex-tests.outputs.tests_passed == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const promoBranch = '${{ steps.validate-merge.outputs.promo_branch }}';
            const featureBranch = '${GITHUB_REF#refs/heads/}';
            const mergeSuccess = '${{ steps.validate-merge.outputs.merge_success }}' === 'true';
            const baseBranch = 'CRM_DevTrial2';
            
            // Push promotional branch (handle existing branch with force-with-lease)
            const { execSync } = require('child_process');
            
            // CRITICAL: Verify there are commits to merge before creating PR
            try {
              const baseCommit = execSync(`git rev-parse origin/${baseBranch}`, { encoding: 'utf8' }).trim();
              const promoCommit = execSync(`git rev-parse HEAD`, { encoding: 'utf8' }).trim();
              
              if (baseCommit === promoCommit) {
                console.error(`[ERROR] ❌ No commits between ${baseBranch} and ${promoBranch}`);
                console.error(`[ERROR] This means the merge was aborted or no changes were merged`);
                console.error(`[ERROR] Base commit: ${baseCommit}`);
                console.error(`[ERROR] Promo commit: ${promoCommit}`);
                console.error(`[ERROR] Workflow should have failed earlier - this is a critical error`);
                process.exit(1);
              }
              
              console.log(`✅ Verified commits exist: ${baseBranch} (${baseCommit.substring(0, 7)}) -> ${promoBranch} (${promoCommit.substring(0, 7)})`);
            } catch (error) {
              console.error(`[ERROR] Failed to verify commits: ${error.message}`);
              process.exit(1);
            }
            try {
              // First, fetch the remote branch to check if it exists
              try {
                execSync(`git fetch origin ${promoBranch}`, { stdio: 'pipe' });
                console.log(`ℹ️ Remote branch ${promoBranch} exists, checking if we need to update`);
                
                // Check if local is ahead or diverged
                const remoteCommit = execSync(`git rev-parse origin/${promoBranch}`, { encoding: 'utf8' }).trim();
                const localCommit = execSync(`git rev-parse HEAD`, { encoding: 'utf8' }).trim();
                
                if (remoteCommit !== localCommit) {
                  console.log(`ℹ️ Local and remote branches differ. Using force-with-lease to update safely.`);
                  execSync(`git push --force-with-lease origin ${promoBranch}`, { stdio: 'inherit' });
                } else {
                  console.log(`ℹ️ Branch ${promoBranch} is already up to date`);
                }
              } catch (fetchError) {
                // Remote branch doesn't exist, push normally
                console.log(`ℹ️ Remote branch ${promoBranch} doesn't exist, creating it`);
                execSync(`git push -u origin ${promoBranch}`, { stdio: 'inherit' });
              }
              console.log(`✅ Promotional branch ${promoBranch} pushed successfully`);
            } catch (error) {
              console.log(`⚠️ Error pushing branch: ${error.message}`);
              if (error.message.includes('up to date') || error.message.includes('already exists')) {
                console.log(`ℹ️ Branch ${promoBranch} is already up to date`);
              } else {
                // Last resort: try force-with-lease
                console.log(`⚠️ Attempting force-with-lease as last resort...`);
                try {
                  execSync(`git push --force-with-lease origin ${promoBranch}`, { stdio: 'inherit' });
                  console.log(`✅ Force push successful`);
                } catch (forceError) {
                  console.error(`❌ Force push also failed: ${forceError.message}`);
                  throw forceError;
                }
              }
            }
            
            // Check if PR already exists
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${promoBranch}`,
              base: 'CRM_DevTrial2',
              state: 'open'
            });
            
            const prBody = `## Promotional Branch Validation Results\n\n**Feature Branch:** \`${featureBranch}\`\n**Promotional Branch:** \`${promoBranch}\`\n\n**Validation Status:** ✅ Passed\n\n**Merge Status:** ${mergeSuccess ? '✅ Success' : '❌ Failed'}\n\n✅ Merge validation passed\n✅ PMD checks passed\n✅ Apex tests validated against promotional branch\n\n⚠️ **Deployment will happen automatically after PR approval and peer review**\n\n✅ Ready for review and merge`;
            
            if (existingPRs.length > 0) {
              // Update existing PR
              const existingPR = existingPRs[0];
              console.log(`ℹ️ PR already exists: ${existingPR.html_url}`);
              
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: existingPR.number,
                body: prBody,
                title: `Promotional Branch: ${promoBranch} (Updated)`
              });
              
              console.log(`✅ PR updated: ${existingPR.html_url}`);
            } else {
              // Create new PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Promotional Branch: ${promoBranch}`,
                head: promoBranch,
                base: 'CRM_DevTrial2',
                body: prBody,
                draft: false
              });
              
              console.log(`✅ PR created: ${pr.html_url}`);
            }

      # Step 13: Summary
      - name: Summary
        if: always()
        run: |
          echo "### Feature Branch Validation Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Feature Branch:** \`${GITHUB_REF#refs/heads/}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Merge Status:** ${{ steps.validate-merge.outputs.merge_success }}" >> $GITHUB_STEP_SUMMARY
          echo "**PMD Checks:** ✅ Completed" >> $GITHUB_STEP_SUMMARY
          
          # Show PMD violations if any
          PMD_VIOLATIONS="${{ steps.pmd-check.outputs.pmd_violations }}"
          if [ -n "$PMD_VIOLATIONS" ] && [ "$PMD_VIOLATIONS" != "0" ] && [ "$PMD_VIOLATIONS" != "" ]; then
            echo "**PMD Violations:** ⚠️ $PMD_VIOLATIONS violation(s) found (non-blocking)" >> $GITHUB_STEP_SUMMARY
            PMD_DETAILS="${{ steps.pmd-check.outputs.pmd_violations_details }}"
            if [ -n "$PMD_DETAILS" ] && [ "$PMD_DETAILS" != "" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Violation Details:**" >> $GITHUB_STEP_SUMMARY
              echo "$PMD_DETAILS" | tr ';' '\n' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "**PMD Violations:** ✅ None" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Show test status
          if [ "${{ steps.apex-tests.outputs.tests_passed }}" = "true" ]; then
            echo "**Apex Tests:** ✅ Passed" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.apex-tests.outcome }}" = "failure" ] || [ "${{ steps.apex-tests.outcome }}" = "cancelled" ]; then
            echo "**Apex Tests:** ❌ Failed" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **Issue:** Test class validation failed. See workflow logs for details." >> $GITHUB_STEP_SUMMARY
          else
            echo "**Apex Tests:** ⏭️ Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.validate-merge.outputs.merge_success }}" = "true" ]; then
            echo "**Promotional Branch:** \`${{ steps.validate-merge.outputs.promo_branch }}\`" >> $GITHUB_STEP_SUMMARY
            echo "**Promotional Branch Contains:** ✅ Delta changes from feature branch merged into CRM_DevTrial2" >> $GITHUB_STEP_SUMMARY
          fi
          echo "**Validation Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ **Status:** All validations passed - PR created/updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Deployment Information" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **Deployment:** Will happen automatically **ONLY after PR approval** (requires 1 peer review)" >> $GITHUB_STEP_SUMMARY
            echo "✅ **Current Status:** PR created - Waiting for peer review approval" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Status:** Validation failed - Please fix issues" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.validate-merge.outputs.merge_success }}" != "true" ]; then
              echo "⚠️ **Issue:** Merge conflict detected. Please resolve conflicts between feature branch and CRM_DevTrial2" >> $GITHUB_STEP_SUMMARY
            fi
            if [ "${{ steps.apex-tests.outputs.tests_passed }}" = "false" ] || [ "${{ steps.apex-tests.outcome }}" = "failure" ]; then
              echo "⚠️ **Issue:** Test class validation failed. Fix test classes and push again." >> $GITHUB_STEP_SUMMARY
            fi
          fi
