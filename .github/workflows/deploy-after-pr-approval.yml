name: Deploy to CRM_DevTrial after PR Merge

on:
  pull_request:
    types: [closed]
    branches:
      - CRM_DevTrial2
    paths-ignore:
      - '**.md'
      - '.gitignore'

jobs:
  deploy-after-merge:
    runs-on: ubuntu-latest
    # Only run if PR was merged (not just closed) and from promotional branch
    if: |
      github.event.pull_request.merged == true &&
      startsWith(github.event.pull_request.head.ref, 'promo/')
    
    permissions:
      contents: write
      pull-requests: write
      checks: write
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          # Use merge commit SHA to ensure we have the merged state
          ref: ${{ github.event.pull_request.merge_commit_sha }}
      
      # Step 2: Configure Git
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step 3: Setup Node
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 4: Install Salesforce CLI
      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global

      # Step 5: Install sfdx-git-delta
      - name: Install sfdx git delta
        run: |
          echo Y | sfdx plugins:install sfdx-git-delta
          sfdx plugins

      # Step 6: Verify PR Merge Status
      - name: Verify PR Merge Status
        id: verify-merge
        run: |
          echo "[INFO] PR #${{ github.event.pull_request.number }} was merged"
          echo "[INFO] Merged by: ${{ github.event.pull_request.merged_by.login }}"
          echo "[INFO] Merge commit: ${{ github.event.pull_request.merge_commit_sha }}"
          echo "[INFO] Source branch: ${{ github.event.pull_request.head.ref }}"
          echo "[INFO] Target branch: ${{ github.event.pull_request.base.ref }}"
          echo "merge_verified=true" >> $GITHUB_OUTPUT

      # Step 7: Generate Delta Packages
      - name: Create delta packages
        id: delta-generation
        if: steps.verify-merge.outputs.merge_verified == 'true'
        run: |
          mkdir -p changed-sources
          BASE_BRANCH="CRM_DevTrial2"
          MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
          
          echo "[INFO] PR was merged - comparing base branch to merge commit"
          echo "[INFO] Merge commit: $MERGE_COMMIT"
          
          # Fetch base branch to ensure we have the reference
          git fetch origin "$BASE_BRANCH" || git fetch origin main
          
          # Get the base commit (parent of merge commit, which is the base branch state before merge)
          # Merge commit has two parents: first parent is base branch, second is head branch
          BASE_COMMIT=$(git rev-parse ${MERGE_COMMIT}^1 2>/dev/null || git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          
          echo "[INFO] Base commit (before merge): $BASE_COMMIT"
          echo "[INFO] Merge commit: $(git rev-parse HEAD)"
          
          # Generate delta from base (before merge) to merge commit
          sf sgd source delta \
            --from "$BASE_COMMIT" \
            --to "$MERGE_COMMIT" \
            --output "changed-sources" \
            --generate-delta \
            --source "force-app" || {
              echo "[WARN] Delta generation failed or no changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              exit 0
            }
          
          echo "[INFO] Delta generation complete"
          
          if [ -d "changed-sources/force-app" ] && [ "$(ls -A changed-sources/force-app 2>/dev/null)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "[INFO] Changes detected in force-app"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "[INFO] No changes detected in force-app"
          fi

      # Step 8: Authorize CRM_DevTrial org (JWT)
      - name: Authorize CRM_DevTrial Org (JWT)
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.delta-generation.outputs.has_changes == 'true'
        run: |
          echo "${{ secrets.SF_JWT_KEY_DEVTRIAL }}" > server.key
          sf org login jwt \
            --username "${{ secrets.SF_USERNAME_DEVTRIAL }}" \
            --jwt-key-file server.key \
            --client-id "${{ secrets.SF_CLIENT_ID_DEVTRIAL }}" \
            --instance-url "${{ secrets.SF_INSTANCE_URL_DEVTRIAL }}" \
            --set-default \
            --alias CRM_DevTrial

      # Step 9: Validate Deployment and Run Tests BEFORE Deployment (Like Change Sets)
      - name: Validate Deployment and Run Tests (Pre-Deployment Check)
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.delta-generation.outputs.has_changes == 'true'
        id: pre-deploy-validation
        continue-on-error: true
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Pre-Deployment Validation (Like Change Sets)"
          echo "[INFO] =========================================="
          
          if [ ! -d "changed-sources/force-app" ] || [ -z "$(ls -A changed-sources/force-app 2>/dev/null)" ]; then
            echo "[INFO] No changes to deploy. Skipping validation."
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "[INFO] Step 1: Validating deployment syntax..."
          # Validate deployment (dry-run) - checks syntax and dependencies
          sf project deploy validate \
            --source-dir changed-sources/force-app \
            --target-org CRM_DevTrial \
            --json > validate_results.json || {
              echo "[ERROR] Deployment validation failed"
              cat validate_results.json
              echo "validation_passed=false" >> $GITHUB_OUTPUT
              exit 1
            }
          
          VALIDATION_STATUS=$(jq -r '.status' validate_results.json 2>/dev/null || echo "unknown")
          echo "[INFO] Validation status: $VALIDATION_STATUS"
          
          if [ "$VALIDATION_STATUS" != "0" ] && [ "$VALIDATION_STATUS" != "Succeeded" ]; then
            echo "[ERROR] Deployment validation failed"
            jq '.result' validate_results.json 2>/dev/null || cat validate_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment validation passed"
          
          echo "[INFO] Step 2: Deploying with test validation (like Change Sets)..."
          echo "[INFO] =========================================="
          echo "[INFO] IMPORTANT: This validates NEW changes from branch against org"
          echo "[INFO] Salesforce CLI with --test-level works like Change Sets:"
          echo "[INFO]   1. Deploys the NEW changes to org"
          echo "[INFO]   2. Runs tests against the NEW changes + existing org code"
          echo "[INFO]   3. If tests fail â†’ Salesforce AUTOMATICALLY rolls back"
          echo "[INFO]   4. If tests pass â†’ Deployment completes successfully"
          echo "[INFO] =========================================="
          
          # Deploy with --test-level: Salesforce validates NEW changes during deployment
          # If tests fail, Salesforce automatically rolls back (like Change Sets)
          set +e
          sf project deploy start \
            --source-dir changed-sources/force-app \
            --target-org CRM_DevTrial \
            --test-level RunLocalTests \
            --wait 10 \
            --json > deploy_with_validation_results.json 2>&1
          DEPLOY_EXIT_CODE=$?
          set -e
          
          if [ ! -f deploy_with_validation_results.json ] || [ ! -s deploy_with_validation_results.json ]; then
            echo "[ERROR] Deployment validation results file is missing or empty"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check deployment status
          DEPLOY_STATUS=$(jq -r '.status // "unknown"' deploy_with_validation_results.json 2>/dev/null || echo "unknown")
          echo "[INFO] Deployment status: $DEPLOY_STATUS"
          
          # Check if tests were run during deployment
          TESTS_RUN=$(jq -r '.result.testsRun // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          TESTS_PASSED=$(jq -r '.result.numberTestsPassed // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          TESTS_FAILED=$(jq -r '.result.numberTestsFailed // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          
          echo "[INFO] Tests run during deployment: $TESTS_RUN"
          echo "[INFO] Tests passed: $TESTS_PASSED"
          echo "[INFO] Tests failed: $TESTS_FAILED"
          
          # Check deployment status and test results
          if [ "$DEPLOY_STATUS" != "0" ] && [ "$DEPLOY_STATUS" != "Succeeded" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment failed or was rolled back"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            jq '.result' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ "$TESTS_RUN" = "0" ] || [ "$TESTS_RUN" = "null" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] No tests were executed during deployment"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            cat deploy_with_validation_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ "$TESTS_FAILED" -gt 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Tests failed during deployment"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            jq '.result.details' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment failed (tests may have failed, causing rollback)"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            cat deploy_with_validation_results.json | head -100
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check code coverage from deployment results
          # Coverage includes NEW changes + existing org code
          COVERAGE_RAW=$(jq -r '.result.coverage // .result.coveragePercentage // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          
          # Also try to calculate from code coverage array
          if [ "$COVERAGE_RAW" = "0" ] || [ "$COVERAGE_RAW" = "null" ]; then
            TOTAL_COVERED=$(jq -r '[.result.codeCoverage[]?.numLinesCovered // 0] | add' deploy_with_validation_results.json 2>/dev/null || echo "0")
            TOTAL_UNCOVERED=$(jq -r '[.result.codeCoverage[]?.numLinesUncovered // 0] | add' deploy_with_validation_results.json 2>/dev/null || echo "0")
            TOTAL_LINES=$((TOTAL_COVERED + TOTAL_UNCOVERED))
            
            if [ "$TOTAL_LINES" -gt 0 ]; then
              COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_LINES" | bc)
              COVERAGE_RAW=$COVERAGE
            fi
          fi
          
          COVERAGE_CLEAN=$(echo "$COVERAGE_RAW" | sed 's/%//g' | sed 's/[^0-9.]//g' | tr -d ' ')
          COVERAGE_NUM=$(echo "$COVERAGE_CLEAN" | awk '{print $1+0}')
          
          echo "[INFO] Code coverage after deployment (with NEW changes): $COVERAGE_NUM%"
          echo "pre_deploy_coverage=$COVERAGE_NUM" >> $GITHUB_OUTPUT
          
          if awk "BEGIN {exit !($COVERAGE_NUM <= 75)}"; then
            echo "[ERROR] Code coverage is below 75% (Current: $COVERAGE_NUM%)"
            echo "[ERROR] Deployment succeeded but coverage is too low"
            jq '.result.summary' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json | head -50
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment completed successfully"
          echo "[INFO] âœ… NEW changes validated against org"
          echo "[INFO] âœ… Tests passed with new changes"
          echo "[INFO] âœ… Coverage check passed ($COVERAGE_NUM% > 75%)"
          echo "validation_passed=true" >> $GITHUB_OUTPUT

      # Step 10: Deployment already completed in Step 9 with test validation
      # This step is now just for logging and final verification
      - name: Verify Deployment Success
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.delta-generation.outputs.has_changes == 'true' && steps.pre-deploy-validation.outputs.validation_passed == 'true'
        id: verify-deployment
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Deployment verification"
          echo "[INFO] Deployment completed in Step 9 with test validation"
          echo "[INFO] =========================================="
          
          if [ ! -f deploy_with_validation_results.json ]; then
            echo "[ERROR] Deployment results file not found"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          DEPLOY_STATUS=$(jq -r '.status // "unknown"' deploy_with_validation_results.json 2>/dev/null || echo "unknown")
          echo "[INFO] Final deployment status: $DEPLOY_STATUS"
          
          if [ "$DEPLOY_STATUS" != "0" ] && [ "$DEPLOY_STATUS" != "Succeeded" ]; then
            echo "[ERROR] Deployment verification failed"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment verified successfully"
          echo "deployment_success=true" >> $GITHUB_OUTPUT

      # Step 11: Verify Post-Deployment Coverage
      - name: Verify Post-Deployment Coverage
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.verify-deployment.outputs.deployment_success == 'true'
        id: apex
        continue-on-error: false
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Post-Deployment Verification"
          echo "[INFO] Verifying org-wide coverage after deployment"
          echo "[INFO] =========================================="
          
          # Run tests again to verify post-deployment state
          set +e
          sf apex run test \
            --test-level RunLocalTests \
            --target-org CRM_DevTrial \
            --code-coverage \
            --json \
            --wait 120 > test_results.json 2>&1
          TEST_EXIT_CODE=$?
          set -e
          
          if [ ! -f test_results.json ] || [ ! -s test_results.json ]; then
            echo "[ERROR] Post-deployment test results file is missing or empty"
            exit 1
          fi
          
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] Post-deployment test execution failed"
            cat test_results.json | head -100
            exit 1
          fi
          
          TEST_STATUS=$(jq -r '.status // "unknown"' test_results.json 2>/dev/null || echo "unknown")
          
          if [ "$TEST_STATUS" != "0" ] && [ "$TEST_STATUS" != "success" ]; then
            echo "[ERROR] Post-deployment tests failed. Status: $TEST_STATUS"
            jq '.result.summary' test_results.json 2>/dev/null || cat test_results.json
            exit 1
          fi
          
          # Calculate post-deployment coverage
          TOTAL_COVERED=$(jq -r '[.result.codeCoverage[]?.numLinesCovered // 0] | add' test_results.json 2>/dev/null || echo "0")
          TOTAL_UNCOVERED=$(jq -r '[.result.codeCoverage[]?.numLinesUncovered // 0] | add' test_results.json 2>/dev/null || echo "0")
          TOTAL_LINES=$((TOTAL_COVERED + TOTAL_UNCOVERED))
          
          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_LINES" | bc)
          else
            COVERAGE_RAW=$(jq -r '.result.summary.orgWideCoverage // 0' test_results.json 2>/dev/null || echo "0")
            COVERAGE=$(echo "$COVERAGE_RAW" | sed 's/%//g' | sed 's/[^0-9.]//g' | tr -d ' ')
          fi
          
          COVERAGE_CLEAN=$(echo "$COVERAGE" | sed 's/[^0-9.]//g')
          COVERAGE_NUM=$(echo "$COVERAGE_CLEAN" | awk '{print $1+0}')
          
          PRE_DEPLOY_COVERAGE="${{ steps.pre-deploy-validation.outputs.pre_deploy_coverage }}"
          
          echo "[INFO] Pre-deployment coverage: ${PRE_DEPLOY_COVERAGE}%"
          echo "[INFO] Post-deployment coverage: $COVERAGE_NUM%"
          
          echo "coverage=$COVERAGE_NUM" >> $GITHUB_OUTPUT
          
          if awk "BEGIN {exit !($COVERAGE_NUM <= 75)}"; then
            echo "[ERROR] Post-deployment org-wide coverage is below 75% (Current: $COVERAGE_NUM%)"
            echo "[ERROR] This should not happen as pre-deployment validation passed"
            jq '.result.summary' test_results.json 2>/dev/null || cat test_results.json | head -50
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "tests_passed=true" >> $GITHUB_OUTPUT
          echo "[INFO] âœ… Post-deployment verification passed"
          echo "[INFO] âœ… Org-wide coverage maintained: $COVERAGE_NUM%"

      # Step 11b: Create Revert PR if Tests Failed During Deployment
      - name: Create Revert PR if Tests Failed
        if: always() && steps.pre-deploy-validation.outcome != 'success' && (steps.pre-deploy-validation.outputs.validation_passed == 'false' || steps.pre-deploy-validation.outputs.tests_failed == 'true' || steps.pre-deploy-validation.outcome == 'failure')
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            
            console.log('[ERROR] Tests failed during deployment - Creating revert PR...');
            console.log('[INFO] Salesforce automatically rolled back from org (no manual action needed)');
            console.log('[INFO] This revert PR will remove the changes from the branch');
            
            const BASE_BRANCH = 'CRM_DevTrial2';
            const MERGE_COMMIT = '${{ github.event.pull_request.merge_commit_sha }}';
            const ORIGINAL_PR_NUMBER = context.payload.pull_request?.number;
            const ORIGINAL_PR_TITLE = context.payload.pull_request?.title || 'Unknown';
            
            try {
              // Configure git
              execSync('git config --global user.name "github-actions[bot]"', { stdio: 'inherit' });
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"', { stdio: 'inherit' });
              
              // Fetch latest
              execSync(`git fetch origin ${BASE_BRANCH}`, { stdio: 'inherit' });
              
              // Create revert branch
              const revertBranch = `revert/${BASE_BRANCH}-pr-${ORIGINAL_PR_NUMBER}-${Date.now()}`;
              execSync(`git checkout -b ${revertBranch} origin/${BASE_BRANCH}`, { stdio: 'inherit' });
              
              // Revert the merge commit
              try {
                execSync(`git revert -m 1 ${MERGE_COMMIT} --no-edit`, { stdio: 'inherit' });
                console.log(`âœ… Successfully reverted merge commit ${MERGE_COMMIT}`);
              } catch (revertError) {
                console.log(`âš ï¸ Automatic revert failed (may have conflicts): ${revertError.message}`);
              }
              
              // Push revert branch
              try {
                execSync(`git push -u origin ${revertBranch}`, { stdio: 'inherit' });
                
                // Create revert PR
                const revertPRBody = `## âš ï¸ Automatic Revert: Tests Failed During Deployment\n\n` +
                  `**Original PR:** #${ORIGINAL_PR_NUMBER}\n` +
                  `**Original PR Title:** ${ORIGINAL_PR_TITLE}\n` +
                  `**Reason:** Tests failed during deployment validation\n\n` +
                  `**âœ… AUTOMATIC ACTIONS TAKEN:**\n` +
                  `- âœ… Salesforce automatically rolled back from org (NO manual rollback needed)\n` +
                  `- âœ… Pipeline stopped - no further actions executed\n` +
                  `- âœ… Revert PR created and will be automatically merged\n` +
                  `- âœ… Changes automatically removed from branch\n\n` +
                  `**Next Steps:**\n` +
                  `1. Fix test failures or coverage issues in original feature branch\n` +
                  `2. Create new PR after fixes\n\n` +
                  `**Note:** Org is already clean - Salesforce automatically rolled back when tests failed.`;
                
                const { data: revertPR } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[AUTO-REVERT] Revert PR #${ORIGINAL_PR_NUMBER}: ${ORIGINAL_PR_TITLE}`,
                  head: revertBranch,
                  base: BASE_BRANCH,
                  body: revertPRBody,
                  draft: false
                });
                
                console.log(`âœ… Revert PR created: ${revertPR.html_url}`);
                
                // Automatically merge the revert PR
                try {
                  console.log(`ðŸ”„ Auto-merging revert PR #${revertPR.number}...`);
                  
                  // Wait a moment for PR to be fully created
                  await new Promise(resolve => setTimeout(resolve, 2000));
                  
                  // Merge the revert PR
                  const mergeResult = await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: revertPR.number,
                    merge_method: 'merge',
                    commit_title: `[AUTO-MERGE] Revert PR #${ORIGINAL_PR_NUMBER}`,
                    commit_message: `Automatically merged revert PR after test failure during deployment`
                  });
                  
                  console.log(`âœ… Revert PR #${revertPR.number} automatically merged successfully`);
                  console.log(`âœ… Changes removed from ${BASE_BRANCH} branch`);
                  
                  // Add a label or comment to mark this as a revert PR so SIT workflows can skip it
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: revertPR.number,
                      labels: ['auto-revert', 'skip-sit-promotion']
                    });
                    console.log(`âœ… Added labels to revert PR to prevent SIT workflows`);
                  } catch (labelError) {
                    console.log(`âš ï¸ Could not add labels: ${labelError.message}`);
                  }
                } catch (mergeError) {
                  console.log(`âš ï¸ Failed to auto-merge revert PR: ${mergeError.message}`);
                  console.log(`âš ï¸ Please manually merge PR #${revertPR.number}: ${revertPR.html_url}`);
                  
                  // If merge fails due to branch protection or other reasons, try to add a comment
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: revertPR.number,
                      body: `âš ï¸ **Auto-merge failed** - Please merge this PR manually to complete the revert.\n\nReason: ${mergeError.message}\n\n**IMPORTANT:** After merging, SIT promotion workflows will be skipped automatically.`
                    });
                  } catch (commentError) {
                    console.log(`âš ï¸ Could not add comment to PR: ${commentError.message}`);
                  }
                }
                
                console.log(`âœ… No org rollback needed - deployment was prevented`);
              } catch (pushError) {
                console.log(`âš ï¸ Failed to push revert branch: ${pushError.message}`);
              }
            } catch (error) {
              console.log(`[ERROR] Failed to create revert PR: ${error.message}`);
            }
            
            console.log('\n[ERROR] âš ï¸ PRE-DEPLOYMENT VALIDATION FAILED');
            console.log('[ERROR] Deployment was prevented - no changes deployed to org');
            console.log('[ERROR] Revert PR created to remove changes from branch');
            
            // Fail the workflow
            process.exit(1);

      # Step 11: Comment on PR
      - name: Comment on PR
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request?.number || context.payload.pull_request.number;
            const merged = context.payload.pull_request?.merged === true;
            const mergedBy = context.payload.pull_request?.merged_by?.login || 'Unknown';
            const deploymentSuccess = '${{ steps.deploy-delta.outputs.deployment_success }}' === 'true';
            const coverage = '${{ steps.apex.outputs.coverage }}';
            const jobStatus = '${{ job.status }}';
            const mergeCommit = context.payload.pull_request?.merge_commit_sha || 'N/A';
            const promoBranch = context.payload.pull_request?.head?.ref || 'N/A';
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            let comment = `## Deployment Status\n\n`;
            
            if (merged && jobStatus === 'success' && deploymentSuccess) {
              comment += `âœ… **Status:** Deployment successful\n`;
              comment += `**Merged by:** @${mergedBy}\n`;
              comment += `**Org-Wide Coverage:** ${coverage}%\n`;
              comment += `âœ… Changes deployed to CRM_DevTrial\n`;
              comment += `âœ… Tests passed\n`;
            } else if (merged && jobStatus === 'success' && !deploymentSuccess) {
              comment += `â„¹ï¸ **Status:** No changes to deploy\n`;
            } else if (merged && jobStatus === 'failure') {
              comment += `âŒ **Status:** Deployment failed\n`;
              comment += `Please check the workflow logs for details.\n`;
            } else {
              comment += `âš ï¸ **Status:** Deployment workflow completed with status: ${jobStatus}\n`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      # Step 12: Summary
      - name: Summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "**PR Status:** Merged âœ…" >> $GITHUB_STEP_SUMMARY
          echo "**Merged by:** ${{ github.event.pull_request.merged_by.login }}" >> $GITHUB_STEP_SUMMARY
          echo "**Merge Commit:** ${{ github.event.pull_request.merge_commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment:** ${{ steps.deploy-delta.outputs.deployment_success }}" >> $GITHUB_STEP_SUMMARY
          echo "**Coverage:** ${{ steps.apex.outputs.coverage }}%" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "âœ… **Deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deployment failed - Check logs for details**" >> $GITHUB_STEP_SUMMARY
          fi
