name: Deploy to CRM_DevTrial after PR Merge

on:
  pull_request:
    types: [closed]
    branches:
      - CRM_DevTrial2
    paths-ignore:
      - '**.md'
      - '.gitignore'

jobs:
  deploy-after-merge:
    runs-on: ubuntu-latest
    # Only run if PR was merged (not just closed) and from promotional branch
    # SKIP revert PRs
    if: |
      github.event.pull_request.merged == true &&
      startsWith(github.event.pull_request.head.ref, 'promo/') &&
      !contains(github.event.pull_request.title, '[AUTO-REVERT]') &&
      !contains(github.event.pull_request.title, '[AUTO-MERGE] Revert') &&
      !contains(github.event.pull_request.head.ref, 'revert/')
    outputs:
      deployment_success: ${{ steps.set-outputs.outputs.deployment_success }}
      has_changes: ${{ steps.delta-generation.outputs.has_changes }}
    
    permissions:
      contents: write
      pull-requests: write
      checks: write
    
    steps:
      # Step 1: Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          # Use merge commit SHA to ensure we have the merged state
          ref: ${{ github.event.pull_request.merge_commit_sha }}
      
      # Step 2: Configure Git
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # Step 3: Setup Node
      - uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 4: Install Salesforce CLI
      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global

      # Step 5: Install sfdx-git-delta
      - name: Install sfdx git delta
        run: |
          echo Y | sfdx plugins:install sfdx-git-delta
          sfdx plugins

      # Step 6: Verify PR Merge Status
      - name: Verify PR Merge Status
        id: verify-merge
        run: |
          echo "[INFO] PR #${{ github.event.pull_request.number }} was merged"
          echo "[INFO] Merged by: ${{ github.event.pull_request.merged_by.login }}"
          echo "[INFO] Merge commit: ${{ github.event.pull_request.merge_commit_sha }}"
          echo "[INFO] Source branch: ${{ github.event.pull_request.head.ref }}"
          echo "[INFO] Target branch: ${{ github.event.pull_request.base.ref }}"
          echo "merge_verified=true" >> $GITHUB_OUTPUT

      # Step 7: Generate Delta Packages
      - name: Create delta packages
        id: delta-generation
        if: steps.verify-merge.outputs.merge_verified == 'true'
        run: |
          mkdir -p changed-sources
          BASE_BRANCH="CRM_DevTrial2"
          MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
          
          echo "[INFO] PR was merged - comparing base branch to merge commit"
          echo "[INFO] Merge commit: $MERGE_COMMIT"
          
          # Fetch base branch to ensure we have the reference
          git fetch origin "$BASE_BRANCH" || git fetch origin main
          
          # Get the base commit (parent of merge commit, which is the base branch state before merge)
          # Merge commit has two parents: first parent is base branch, second is head branch
          BASE_COMMIT=$(git rev-parse ${MERGE_COMMIT}^1 2>/dev/null || git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          
          echo "[INFO] Base commit (before merge): $BASE_COMMIT"
          echo "[INFO] Merge commit: $(git rev-parse HEAD)"
          
          # Generate delta from base (before merge) to merge commit
          sf sgd source delta \
            --from "$BASE_COMMIT" \
            --to "$MERGE_COMMIT" \
            --output-dir "changed-sources" \
            --generate-delta \
            --source-dir "force-app" || {
              echo "[WARN] Delta generation failed or no changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              exit 0
            }
          
          echo "[INFO] Delta generation complete"
          
          if [ -d "changed-sources/force-app" ] && [ "$(ls -A changed-sources/force-app 2>/dev/null)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "[INFO] Changes detected in force-app"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "[INFO] No changes detected in force-app"
          fi

      # Step 8: Authorize CRM_DevTrial org (JWT)
      - name: Authorize CRM_DevTrial Org (JWT)
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.delta-generation.outputs.has_changes == 'true'
        run: |
          echo "${{ secrets.SF_JWT_KEY_DEVTRIAL }}" > server.key
          sf org login jwt \
            --username "${{ secrets.SF_USERNAME_DEVTRIAL }}" \
            --jwt-key-file server.key \
            --client-id "${{ secrets.SF_CLIENT_ID_DEVTRIAL }}" \
            --instance-url "${{ secrets.SF_INSTANCE_URL_DEVTRIAL }}" \
            --set-default \
            --alias CRM_DevTrial

      # Step 9: Validate Deployment and Run Tests BEFORE Deployment (Like Change Sets)
      - name: Validate Deployment and Run Tests (Pre-Deployment Check)
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.delta-generation.outputs.has_changes == 'true'
        id: pre-deploy-validation
        continue-on-error: true
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Pre-Deployment Validation (Like Change Sets)"
          echo "[INFO] =========================================="
          
          if [ ! -d "changed-sources/force-app" ] || [ -z "$(ls -A changed-sources/force-app 2>/dev/null)" ]; then
            echo "[INFO] No changes to deploy. Skipping validation."
            echo "validation_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "[INFO] Step 1: Validating deployment syntax..."
          # Validate deployment (dry-run) - checks syntax and dependencies
          sf project deploy validate \
            --source-dir changed-sources/force-app \
            --target-org CRM_DevTrial \
            --json > validate_results.json || {
              echo "[ERROR] Deployment validation failed"
              cat validate_results.json
              echo "validation_passed=false" >> $GITHUB_OUTPUT
              exit 1
            }
          
          VALIDATION_STATUS=$(jq -r '.status' validate_results.json 2>/dev/null || echo "unknown")
          echo "[INFO] Validation status: $VALIDATION_STATUS"
          
          if [ "$VALIDATION_STATUS" != "0" ] && [ "$VALIDATION_STATUS" != "Succeeded" ]; then
            echo "[ERROR] Deployment validation failed"
            jq '.result' validate_results.json 2>/dev/null || cat validate_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment validation passed"
          
          echo "[INFO] Step 2: Deploying with test validation (like Change Sets)..."
          echo "[INFO] =========================================="
          echo "[INFO] IMPORTANT: This validates NEW changes from branch against org"
          echo "[INFO] Salesforce CLI with --test-level works like Change Sets:"
          echo "[INFO]   1. Deploys the NEW changes to org"
          echo "[INFO]   2. Runs tests against the NEW changes + existing org code"
          echo "[INFO]   3. If tests fail â†’ Salesforce AUTOMATICALLY rolls back"
          echo "[INFO]   4. If tests pass â†’ Deployment completes successfully"
          echo "[INFO] =========================================="
          
          # Deploy with --test-level: Salesforce validates NEW changes during deployment
          # If tests fail, Salesforce automatically rolls back (like Change Sets)
          set +e
          sf project deploy start \
            --source-dir changed-sources/force-app \
            --target-org CRM_DevTrial \
            --test-level RunLocalTests \
            --wait 10 \
            --json > deploy_with_validation_results.json 2>&1
          DEPLOY_EXIT_CODE=$?
          set -e
          
          if [ ! -f deploy_with_validation_results.json ] || [ ! -s deploy_with_validation_results.json ]; then
            echo "[ERROR] Deployment validation results file is missing or empty"
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check deployment status
          DEPLOY_STATUS=$(jq -r '.status // "unknown"' deploy_with_validation_results.json 2>/dev/null || echo "unknown")
          echo "[INFO] Deployment status: $DEPLOY_STATUS"
          
          # Check if tests were run during deployment
          # Salesforce returns: result.numberTestsCompleted, result.details.runTestResult.numTestsRun, result.details.runTestResult.numFailures
          TESTS_RUN=$(jq -r '.result.numberTestsCompleted // .result.details.runTestResult.numTestsRun // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          TESTS_PASSED=$(jq -r '.result.numberTestsCompleted // .result.details.runTestResult.numTestsRun // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          TESTS_FAILED=$(jq -r '.result.details.runTestResult.numFailures // .result.numberTestErrors // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          
          echo "[INFO] Tests run during deployment: $TESTS_RUN"
          echo "[INFO] Tests passed: $TESTS_PASSED"
          echo "[INFO] Tests failed: $TESTS_FAILED"
          
          # Check deployment status and test results
          if [ "$DEPLOY_STATUS" != "0" ] && [ "$DEPLOY_STATUS" != "Succeeded" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment failed or was rolled back"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            jq '.result' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ "$TESTS_RUN" = "0" ] || [ "$TESTS_RUN" = "null" ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] No tests were executed during deployment"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment result structure (check result.details.runTestResult):"
            jq '.result.details.runTestResult // .result' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ "$TESTS_FAILED" -gt 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Tests failed during deployment ($TESTS_FAILED test(s) failed)"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            echo "[ERROR] Failed test(s):"
            jq -r '.result.details.runTestResult.failures[]? | "  - \(.name).\(.methodName): \(.message)"' deploy_with_validation_results.json 2>/dev/null || true
            jq '.result.details.runTestResult.failures // .result.details' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $DEPLOY_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Deployment failed (tests may have failed, causing rollback)"
            echo "[ERROR] Salesforce automatically rolled back from org (no manual action needed)"
            echo "[ERROR] Pipeline will stop here - no further actions will execute"
            echo "[ERROR] A revert PR will be created to remove changes from branch"
            echo "[ERROR] =========================================="
            cat deploy_with_validation_results.json | head -100
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            echo "tests_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check code coverage from deployment results
          # Coverage includes NEW changes + existing org code
          # Path: result.details.runTestResult.codeCoverage (deploy) or result.codeCoverage (apex run test)
          COVERAGE_RAW=$(jq -r '.result.coverage // .result.coveragePercentage // 0' deploy_with_validation_results.json 2>/dev/null || echo "0")
          
          # Also try to calculate from code coverage array (runTestResult.codeCoverage uses numLocations/numLocationsNotCovered)
          if [ "$COVERAGE_RAW" = "0" ] || [ "$COVERAGE_RAW" = "null" ]; then
            TOTAL_COVERED=$(jq -r '[.result.details.runTestResult.codeCoverage[]? | ((.numLocations // 0) - (.numLocationsNotCovered // 0))] | add' deploy_with_validation_results.json 2>/dev/null || jq -r '[.result.codeCoverage[]?.numLinesCovered // 0] | add' deploy_with_validation_results.json 2>/dev/null || echo "0")
            TOTAL_UNCOVERED=$(jq -r '[.result.details.runTestResult.codeCoverage[]?.numLocationsNotCovered // 0] | add' deploy_with_validation_results.json 2>/dev/null || jq -r '[.result.codeCoverage[]?.numLinesUncovered // 0] | add' deploy_with_validation_results.json 2>/dev/null || echo "0")
            TOTAL_LINES=$((TOTAL_COVERED + TOTAL_UNCOVERED))
            
            if [ "$TOTAL_LINES" -gt 0 ]; then
              COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_LINES" | bc)
              COVERAGE_RAW=$COVERAGE
            fi
          fi
          
          COVERAGE_CLEAN=$(echo "$COVERAGE_RAW" | sed 's/%//g' | sed 's/[^0-9.]//g' | tr -d ' ')
          COVERAGE_NUM=$(echo "$COVERAGE_CLEAN" | awk '{print $1+0}')
          
          echo "[INFO] Code coverage after deployment (with NEW changes): $COVERAGE_NUM%"
          echo "pre_deploy_coverage=$COVERAGE_NUM" >> $GITHUB_OUTPUT
          
          if awk "BEGIN {exit !($COVERAGE_NUM <= 75)}"; then
            echo "[ERROR] =========================================="
            echo "[ERROR] Code coverage is below 75% (Current: $COVERAGE_NUM%)"
            echo "[ERROR] Deployment succeeded but coverage is too low - Salesforce may have rolled back"
            echo "[ERROR] Per-class coverage (NEW changes validated):"
            jq -r '.result.details.runTestResult.codeCoverage[]? | "  - \(.name): \(.numLocations - .numLocationsNotCovered)/\(.numLocations) locations covered"' deploy_with_validation_results.json 2>/dev/null || true
            echo "[ERROR] =========================================="
            jq '.result.details.runTestResult.codeCoverage // .result.summary' deploy_with_validation_results.json 2>/dev/null || cat deploy_with_validation_results.json | head -50
            echo "validation_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment completed successfully"
          echo "[INFO] âœ… NEW changes validated against org"
          echo "[INFO] âœ… Tests passed with new changes"
          echo "[INFO] âœ… Coverage check passed ($COVERAGE_NUM% > 75%)"
          echo "validation_passed=true" >> $GITHUB_OUTPUT

      # Step 10: Deployment already completed in Step 9 with test validation
      # This step is now just for logging and final verification
      - name: Verify Deployment Success
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.delta-generation.outputs.has_changes == 'true' && steps.pre-deploy-validation.outputs.validation_passed == 'true'
        id: verify-deployment
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Deployment verification"
          echo "[INFO] Deployment completed in Step 9 with test validation"
          echo "[INFO] =========================================="
          
          if [ ! -f deploy_with_validation_results.json ]; then
            echo "[ERROR] Deployment results file not found"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          DEPLOY_STATUS=$(jq -r '.status // "unknown"' deploy_with_validation_results.json 2>/dev/null || echo "unknown")
          echo "[INFO] Final deployment status: $DEPLOY_STATUS"
          
          if [ "$DEPLOY_STATUS" != "0" ] && [ "$DEPLOY_STATUS" != "Succeeded" ]; then
            echo "[ERROR] Deployment verification failed"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "[INFO] âœ… Deployment verified successfully"
          echo "deployment_success=true" >> $GITHUB_OUTPUT

      # Step 11: Verify Post-Deployment Coverage
      - name: Verify Post-Deployment Coverage
        if: steps.verify-merge.outputs.merge_verified == 'true' && steps.verify-deployment.outputs.deployment_success == 'true'
        id: apex
        continue-on-error: false
        run: |
          echo "[INFO] =========================================="
          echo "[INFO] Post-Deployment Verification"
          echo "[INFO] Verifying org-wide coverage after deployment"
          echo "[INFO] =========================================="
          
          # Run tests again to verify post-deployment state
          set +e
          sf apex run test \
            --test-level RunLocalTests \
            --target-org CRM_DevTrial \
            --code-coverage \
            --json \
            --wait 120 > test_results.json 2>&1
          TEST_EXIT_CODE=$?
          set -e
          
          if [ ! -f test_results.json ] || [ ! -s test_results.json ]; then
            echo "[ERROR] Post-deployment test results file is missing or empty"
            exit 1
          fi
          
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "[ERROR] Post-deployment test execution failed"
            cat test_results.json | head -100
            exit 1
          fi
          
          TEST_STATUS=$(jq -r '.status // "unknown"' test_results.json 2>/dev/null || echo "unknown")
          
          if [ "$TEST_STATUS" != "0" ] && [ "$TEST_STATUS" != "success" ]; then
            echo "[ERROR] Post-deployment tests failed. Status: $TEST_STATUS"
            jq '.result.summary' test_results.json 2>/dev/null || cat test_results.json
            exit 1
          fi
          
          # Calculate post-deployment coverage
          TOTAL_COVERED=$(jq -r '[.result.codeCoverage[]?.numLinesCovered // 0] | add' test_results.json 2>/dev/null || echo "0")
          TOTAL_UNCOVERED=$(jq -r '[.result.codeCoverage[]?.numLinesUncovered // 0] | add' test_results.json 2>/dev/null || echo "0")
          TOTAL_LINES=$((TOTAL_COVERED + TOTAL_UNCOVERED))
          
          if [ "$TOTAL_LINES" -gt 0 ]; then
            COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_LINES" | bc)
          else
            COVERAGE_RAW=$(jq -r '.result.summary.orgWideCoverage // 0' test_results.json 2>/dev/null || echo "0")
            COVERAGE=$(echo "$COVERAGE_RAW" | sed 's/%//g' | sed 's/[^0-9.]//g' | tr -d ' ')
          fi
          
          COVERAGE_CLEAN=$(echo "$COVERAGE" | sed 's/[^0-9.]//g')
          COVERAGE_NUM=$(echo "$COVERAGE_CLEAN" | awk '{print $1+0}')
          
          PRE_DEPLOY_COVERAGE="${{ steps.pre-deploy-validation.outputs.pre_deploy_coverage }}"
          
          echo "[INFO] Pre-deployment coverage: ${PRE_DEPLOY_COVERAGE}%"
          echo "[INFO] Post-deployment coverage: $COVERAGE_NUM%"
          
          echo "coverage=$COVERAGE_NUM" >> $GITHUB_OUTPUT
          
          if awk "BEGIN {exit !($COVERAGE_NUM <= 75)}"; then
            echo "[ERROR] Post-deployment org-wide coverage is below 75% (Current: $COVERAGE_NUM%)"
            echo "[ERROR] This should not happen as pre-deployment validation passed"
            jq '.result.summary' test_results.json 2>/dev/null || cat test_results.json | head -50
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "tests_passed=true" >> $GITHUB_OUTPUT
          echo "[INFO] âœ… Post-deployment verification passed"
          echo "[INFO] âœ… Org-wide coverage maintained: $COVERAGE_NUM%"

      # Step 11b: Create Revert PR if Tests Failed During Deployment
      - name: Create Revert PR if Tests Failed
        if: always() && steps.pre-deploy-validation.outcome != 'success' && (steps.pre-deploy-validation.outputs.validation_passed == 'false' || steps.pre-deploy-validation.outputs.tests_failed == 'true' || steps.pre-deploy-validation.outcome == 'failure')
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            
            console.log('[ERROR] Tests failed during deployment - Creating revert PR...');
            console.log('[INFO] Salesforce automatically rolled back from org (no manual action needed)');
            console.log('[INFO] This revert PR will remove the changes from the branch');
            
            const BASE_BRANCH = 'CRM_DevTrial2';
            const MERGE_COMMIT = '${{ github.event.pull_request.merge_commit_sha }}';
            const ORIGINAL_PR_NUMBER = context.payload.pull_request?.number;
            const ORIGINAL_PR_TITLE = context.payload.pull_request?.title || 'Unknown';
            
            try {
              // Configure git
              execSync('git config --global user.name "github-actions[bot]"', { stdio: 'inherit' });
              execSync('git config --global user.email "github-actions[bot]@users.noreply.github.com"', { stdio: 'inherit' });
              
              // Fetch latest
              execSync(`git fetch origin ${BASE_BRANCH}`, { stdio: 'inherit' });
              
              // Create revert branch
              const revertBranch = `revert/${BASE_BRANCH}-pr-${ORIGINAL_PR_NUMBER}-${Date.now()}`;
              execSync(`git checkout -b ${revertBranch} origin/${BASE_BRANCH}`, { stdio: 'inherit' });
              
              // Revert the merge commit
              try {
                execSync(`git revert -m 1 ${MERGE_COMMIT} --no-edit`, { stdio: 'inherit' });
                console.log(`âœ… Successfully reverted merge commit ${MERGE_COMMIT}`);
              } catch (revertError) {
                console.log(`âš ï¸ Automatic revert failed (may have conflicts): ${revertError.message}`);
              }
              
              // Push revert branch
              try {
                execSync(`git push -u origin ${revertBranch}`, { stdio: 'inherit' });
                
                // Create revert PR
                const revertPRBody = `## âš ï¸ Automatic Revert: Tests Failed During Deployment\n\n` +
                  `**Original PR:** #${ORIGINAL_PR_NUMBER}\n` +
                  `**Original PR Title:** ${ORIGINAL_PR_TITLE}\n` +
                  `**Reason:** Tests failed during deployment validation\n\n` +
                  `**âœ… AUTOMATIC ACTIONS TAKEN:**\n` +
                  `- âœ… Salesforce automatically rolled back from org (NO manual rollback needed)\n` +
                  `- âœ… Pipeline stopped - no further actions executed\n` +
                  `- âœ… Revert PR created and will be automatically merged\n` +
                  `- âœ… Changes automatically removed from branch\n\n` +
                  `**Next Steps:**\n` +
                  `1. Fix test failures or coverage issues in original feature branch\n` +
                  `2. Create new PR after fixes\n\n` +
                  `**Note:** Org is already clean - Salesforce automatically rolled back when tests failed.`;
                
                const { data: revertPR } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[AUTO-REVERT] Revert PR #${ORIGINAL_PR_NUMBER}: ${ORIGINAL_PR_TITLE}`,
                  head: revertBranch,
                  base: BASE_BRANCH,
                  body: revertPRBody,
                  draft: false
                });
                
                console.log(`âœ… Revert PR created: ${revertPR.html_url}`);
                
                // Automatically merge the revert PR
                try {
                  console.log(`ðŸ”„ Auto-merging revert PR #${revertPR.number}...`);
                  
                  // Wait a moment for PR to be fully created
                  await new Promise(resolve => setTimeout(resolve, 2000));
                  
                  // Merge the revert PR
                  const mergeResult = await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: revertPR.number,
                    merge_method: 'merge',
                    commit_title: `[AUTO-MERGE] Revert PR #${ORIGINAL_PR_NUMBER}`,
                    commit_message: `Automatically merged revert PR after test failure during deployment`
                  });
                  
                  console.log(`âœ… Revert PR #${revertPR.number} automatically merged successfully`);
                  console.log(`âœ… Changes removed from ${BASE_BRANCH} branch`);
                  
                  // Add a label or comment to mark this as a revert PR so SIT workflows can skip it
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: revertPR.number,
                      labels: ['auto-revert', 'skip-sit-promotion']
                    });
                    console.log(`âœ… Added labels to revert PR to prevent SIT workflows`);
                  } catch (labelError) {
                    console.log(`âš ï¸ Could not add labels: ${labelError.message}`);
                  }
                } catch (mergeError) {
                  console.log(`âš ï¸ Failed to auto-merge revert PR: ${mergeError.message}`);
                  console.log(`âš ï¸ Please manually merge PR #${revertPR.number}: ${revertPR.html_url}`);
                  
                  // If merge fails due to branch protection or other reasons, try to add a comment
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: revertPR.number,
                      body: `âš ï¸ **Auto-merge failed** - Please merge this PR manually to complete the revert.\n\nReason: ${mergeError.message}\n\n**IMPORTANT:** After merging, SIT promotion workflows will be skipped automatically.`
                    });
                  } catch (commentError) {
                    console.log(`âš ï¸ Could not add comment to PR: ${commentError.message}`);
                  }
                }
                
                console.log(`âœ… No org rollback needed - deployment was prevented`);
              } catch (pushError) {
                console.log(`âš ï¸ Failed to push revert branch: ${pushError.message}`);
              }
            } catch (error) {
              console.log(`[ERROR] Failed to create revert PR: ${error.message}`);
            }
            
            console.log('\n[ERROR] âš ï¸ PRE-DEPLOYMENT VALIDATION FAILED');
            console.log('[ERROR] Deployment was prevented - no changes deployed to org');
            console.log('[ERROR] Revert PR created to remove changes from branch');
            
            // Fail the workflow
            process.exit(1);

      # Step 10b: Set job outputs for dependent jobs
      - name: Set job outputs
        id: set-outputs
        if: always()
        run: |
          DEPLOY_SUCCESS="${{ steps.verify-deployment.outputs.deployment_success }}"
          echo "deployment_success=${DEPLOY_SUCCESS:-false}" >> $GITHUB_OUTPUT

      # Step 11: Comment on PR
      - name: Comment on PR
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request?.number || context.payload.pull_request.number;
            const merged = context.payload.pull_request?.merged === true;
            const mergedBy = context.payload.pull_request?.merged_by?.login || 'Unknown';
            const deploymentSuccess = '${{ steps.verify-deployment.outputs.deployment_success }}' === 'true';
            const coverage = '${{ steps.apex.outputs.coverage }}';
            const jobStatus = '${{ job.status }}';
            const mergeCommit = context.payload.pull_request?.merge_commit_sha || 'N/A';
            const promoBranch = context.payload.pull_request?.head?.ref || 'N/A';
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            let comment = `## Deployment Status\n\n`;
            
            if (merged && jobStatus === 'success' && deploymentSuccess) {
              comment += `âœ… **Status:** Deployment successful\n`;
              comment += `**Merged by:** @${mergedBy}\n`;
              comment += `**Org-Wide Coverage:** ${coverage}%\n`;
              comment += `âœ… Changes deployed to CRM_DevTrial\n`;
              comment += `âœ… Tests passed\n`;
            } else if (merged && jobStatus === 'success' && !deploymentSuccess) {
              comment += `â„¹ï¸ **Status:** No changes to deploy\n`;
            } else if (merged && jobStatus === 'failure') {
              comment += `âŒ **Status:** Deployment failed\n`;
              comment += `Please check the workflow logs for details.\n`;
            } else {
              comment += `âš ï¸ **Status:** Deployment workflow completed with status: ${jobStatus}\n`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

      # Step 12: Summary
      - name: Summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "**PR Status:** Merged âœ…" >> $GITHUB_STEP_SUMMARY
          echo "**Merged by:** ${{ github.event.pull_request.merged_by.login }}" >> $GITHUB_STEP_SUMMARY
          echo "**Merge Commit:** ${{ github.event.pull_request.merge_commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment:** ${{ steps.verify-deployment.outputs.deployment_success }}" >> $GITHUB_STEP_SUMMARY
          echo "**Coverage:** ${{ steps.apex.outputs.coverage }}%" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ job.status }}" = "success" ]; then
            echo "âœ… **Deployment completed successfully**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deployment failed - Check logs for details**" >> $GITHUB_STEP_SUMMARY
          fi

  # SIT Promotion - runs ONLY after successful DevTrial deployment (sequential)
  promote-to-sit:
    runs-on: ubuntu-latest
    needs: deploy-after-merge
    if: needs.deploy-after-merge.outputs.deployment_success == 'true' && needs.deploy-after-merge.outputs.has_changes == 'true'
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.event.pull_request.merge_commit_sha }}
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install Salesforce CLI
        run: npm install @salesforce/cli --global
      - name: Install sfdx git delta
        run: |
          echo Y | sfdx plugins:install sfdx-git-delta
          sfdx plugins
      - name: Install required tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y jq bc -qq
      - name: Create SIT Promotional Branch
        id: create-sit-promo
        run: |
          PROMO_BRANCH="${{ github.event.pull_request.head.ref }}"
          FEATURE_NUM=$(echo "$PROMO_BRANCH" | sed 's/promo\///g')
          SIT_PROMO_BRANCH="sit-promo/$FEATURE_NUM"
          echo "[INFO] Original promo branch: $PROMO_BRANCH"
          echo "[INFO] Creating SIT promotional branch: $SIT_PROMO_BRANCH"
          git fetch origin CRM_SITTrial || git fetch origin main
          BASE_BRANCH="CRM_SITTrial"
          if git ls-remote --heads origin "$SIT_PROMO_BRANCH" | grep -q "$SIT_PROMO_BRANCH"; then
            git fetch origin "$SIT_PROMO_BRANCH"
            git checkout -b "$SIT_PROMO_BRANCH" "origin/$SIT_PROMO_BRANCH" 2>/dev/null || git checkout "$SIT_PROMO_BRANCH"
            git reset --hard origin/$BASE_BRANCH || git reset --hard origin/main
          else
            git checkout -b "$SIT_PROMO_BRANCH" origin/$BASE_BRANCH || git checkout -b "$SIT_PROMO_BRANCH" origin/main
          fi
          MERGE_COMMIT="${{ github.event.pull_request.merge_commit_sha }}"
          if git merge-base --is-ancestor "$MERGE_COMMIT" HEAD 2>/dev/null; then
            echo "sit_promo_branch=$SIT_PROMO_BRANCH" >> $GITHUB_OUTPUT
            echo "merge_success=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          git merge --no-ff "$MERGE_COMMIT" -m "Merge $MERGE_COMMIT from CRM_DevTrial2 into SIT promotional branch" || {
            git merge --abort 2>/dev/null || true
            echo "merge_success=false" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "sit_promo_branch=$SIT_PROMO_BRANCH" >> $GITHUB_OUTPUT
          echo "merge_success=true" >> $GITHUB_OUTPUT
          echo "[INFO] âœ… SIT promotional branch created"
      - name: Generate Delta Packages for SIT
        id: delta-generation-sit
        if: steps.create-sit-promo.outputs.merge_success == 'true'
        run: |
          mkdir -p changed-sources-sit
          SIT_PROMO_BRANCH="${{ steps.create-sit-promo.outputs.sit_promo_branch }}"
          BASE_BRANCH="CRM_SITTrial"
          git fetch origin "$BASE_BRANCH" || git fetch origin main
          BASE_COMMIT=$(git rev-parse origin/$BASE_BRANCH 2>/dev/null || git rev-parse origin/main)
          sf sgd source delta --from "$BASE_COMMIT" --to "HEAD" --output-dir "changed-sources-sit" --generate-delta --source-dir "force-app" || { echo "has_changes=false" >> $GITHUB_OUTPUT; exit 0; }
          if [ -d "changed-sources-sit/force-app" ] && [ "$(ls -A changed-sources-sit/force-app 2>/dev/null)" ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
      - name: Run PMD Apex Checks for SIT
        id: pmd-check-sit
        continue-on-error: true
        if: steps.create-sit-promo.outputs.merge_success == 'true' && steps.delta-generation-sit.outputs.has_changes == 'true'
        run: |
          chmod +x scripts/pmd-check.sh scripts/enhanced-pmd-check.sh 2>/dev/null || true
          scripts/pmd-check.sh changed-sources-sit/force-app .pmd/apex-ruleset.xml 2>&1 | tee pmd-output-sit.log || true
          VIOLATION_COUNT=$(cat pmd-violation-count.txt 2>/dev/null || echo "0")
          echo "pmd_passed=true" >> $GITHUB_OUTPUT
          echo "pmd_violations=$VIOLATION_COUNT" >> $GITHUB_OUTPUT
      - name: Run Apex Tests against SIT Promotional Branch
        id: apex-tests-sit
        if: steps.create-sit-promo.outputs.merge_success == 'true' && steps.delta-generation-sit.outputs.has_changes == 'true'
        run: |
          chmod +x scripts/run-apex-tests.sh
          scripts/run-apex-tests.sh force-app test_results_sit.json
          echo "tests_passed=true" >> $GITHUB_OUTPUT
      - name: Push SIT Promotional Branch and Create/Update PR
        if: steps.create-sit-promo.outputs.merge_success == 'true' && steps.pmd-check-sit.outputs.pmd_passed == 'true' && steps.apex-tests-sit.outputs.tests_passed == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const sitPromoBranch = '${{ steps.create-sit-promo.outputs.sit_promo_branch }}';
            const originalPromoBranch = '${{ github.event.pull_request.head.ref }}';
            const { execSync } = require('child_process');
            try {
              try {
                execSync(`git fetch origin ${sitPromoBranch}`, { stdio: 'pipe' });
                const remoteCommit = execSync(`git rev-parse origin/${sitPromoBranch}`, { encoding: 'utf8' }).trim();
                const localCommit = execSync(`git rev-parse HEAD`, { encoding: 'utf8' }).trim();
                if (remoteCommit !== localCommit) {
                  execSync(`git push --force-with-lease origin ${sitPromoBranch}`, { stdio: 'inherit' });
                }
              } catch (e) {
                execSync(`git push -u origin ${sitPromoBranch}`, { stdio: 'inherit' });
              }
            } catch (err) {
              execSync(`git push --force-with-lease origin ${sitPromoBranch}`, { stdio: 'inherit' });
            }
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${sitPromoBranch}`,
              base: 'CRM_SITTrial',
              state: 'open'
            });
            const prBody = `## SIT Promotional Branch (Deployed to CRM_DevTrial âœ…)\n\n**Original:** \`${originalPromoBranch}\`\n**SIT Branch:** \`${sitPromoBranch}\`\n**Source:** CRM_DevTrial2 PR #${{ github.event.pull_request.number }}\n\nâœ… DevTrial deployment succeeded\nâœ… PMD passed\nâœ… Apex tests validated\n\n**Deployment to CRM_SITOrg happens automatically after this PR is merged.**`;
            if (existingPRs.length > 0) {
              await github.rest.pulls.update({ owner: context.repo.owner, repo: context.repo.repo, pull_number: existingPRs[0].number, body: prBody });
              console.log(`âœ… PR updated: ${existingPRs[0].html_url}`);
            } else {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `SIT Promotional Branch: ${sitPromoBranch}`,
                head: sitPromoBranch,
                base: 'CRM_SITTrial',
                body: prBody,
                draft: false
              });
              console.log(`âœ… PR created: ${pr.html_url}`);
            }
